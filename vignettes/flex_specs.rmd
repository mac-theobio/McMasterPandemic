---
title: "Flexible Compartmental Modelling Specifications"
author: "Steve Walker, Weiguang Guan, Ben Bolker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flexible Compartmental Modelling Specifications}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

[![Live Version](https://img.shields.io/static/v1.svg?label=Live&message=Document&color=green)](https://canmod.net/misc/flex_specs)

[McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic) is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This refactoring will be done incrementally by implementing a series of versioned specifications that define each step. This document outlines these specifications, and provides a roadmap for planning future specifications.

# Table of Contents

* [Versioning and Lifecycle](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)
* [Version Summary](https://canmod.net/misc/flex_specs#version-summary)
* [Version Descriptions](https://canmod.net/misc/flex_specs#version-descriptions)

# Versioning and Lifecycle

We are using semantic versioning https://semver.org/ to provide versions for the specs. All versions of a spec that have not been implemented in a released version of the McMasterPandemic R package have major version 0 (e.g. 0.x.y, https://semver.org#spec-item-4) -- currently all of them. Although none of these specs are released, they are being experimentally implemented on the [TMB branch of McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic/tree/tmb), with R-side code [here](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/R/tmb.R). There is a global option, `MP_flex_spec_version`, that is used by this `R` code to control what spec version is being assumed by the `TMB`/`C++` code. This helps in [testing](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/tests/testthat/test-tmb.R) as well. `C++` files that implement various spec versions are currently being placed [here](https://github.com/mac-theobio/McMasterPandemic/tree/tmb/inst/tmb).

Spec versions have three life cycle stages: frozen, experimental, and archived. If a frozen version needs clarification or updating, this clarification must be done by linking to a subsequent version that addresses the issue(s). Each frozen version of the spec must contain the following five sections.

* _New Capabilities_ -- very short summary; refer to previous versions for background
* _Assumptions_ -- known assumptions that can help users/developers understand if this version will suite their needs
* _Mathematical Description_ -- precise definition of the new or changed features of the model; refer to previous versions for definitions being reused
* _User Interface_ -- short description and example of the user interface in `R` for model specification
* _Data Structure_ -- definition of the data structure to be passed from `R` to `TMB`/`C++` that stores the model structure

# Version Summary

## Frozen Versions

The specs for the following versions are frozen, which means that they will not change.

* [0.0.1 -- Simple rate matrix updates](#v0.0.1)
* [0.0.2 -- Simulation (iterated state variable updates)](#v0.0.2)

## Experimental Versions

The specs for the following versions are being actively developed and modified. These versions also serve as a roadmap. Note that version numbers of experimental versions can change without warning.

* [0.0.3 -- Time-varying parameters](#v0.0.3)
* [0.0.4 -- Model structure](#v0.0.4)
* [0.0.5 -- Condensation and calibration](#v0.0.5)
* [0.0.6 -- Hazard and ODE simulation](#v0.0.6)
* [0.0.7 -- Stochasticity](#v0.0.7)
* [0.0.8 -- State dependent time-variation of parameters](#v0.0.8)

## Archived Versions

The specs for archived versions are frozen but no longer respected by the `McMasterPandemic` `R` package and/or its test framework. Archived versions cannot be ignored because Frozen and Experimental versions may still reference them. Currently no versions are archived.

# Version Descriptions

## v0.0.8

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities 0.0.8

State dependent time-variation of parameters.

## v0.0.7

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities 0.0.7

Stochasticity.

## v0.0.6

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities 0.0.6

Hazard and exponential simulation.

## v0.0.5

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities 0.0.5

Condensation and calibration.

## v0.0.4

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.4)

Model structure (e.g. vaccination, age, testing) by modifying the user interface to accept matrix/vector inputs. There are two ways to do this: (1)  expand the inputs to fit into the scalar models below or (2) pass the inputs directly to `TMB`/`C++` and modify the code on that side.

## v0.0.3

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

There is a lot here for this version, but it is far from complete/correct and still pretty scattered.

### New Capabilities (0.0.3)

Time-varying parameters.

### Assumptions (0.0.3)

* Time-varying parameters cannot be accumulators

### Mathematical Description (0.0.3)

$$
\log(u) = \log(u_0) + Xv
$$
where $u$ is a vector of length $T$, the number of time steps, $u_0$ is a scalar parameter, $v$ is a vector of length $D < T$ that parameterizes the model of time variation, and $X$ is a $T$-by-$D$ matrix of constant columns (e.g. indicator variables, spline bases). Note that logs of vectors are taken element-wise.

$$
\log(u_t) = \log(u_0) + \sum_{i=1}^Dx_{ti}v_i
$$
$$
u_t = u_0 \prod_{i=1}^D\exp\left(x_{ti}v_i\right)
$$
For example:

* $D=2$ breakpoints 
* $v_1 = v_2 = \log\left(\frac{1}{2}\right) \approx -0.69$
* $x_{ti} = \begin{cases} 1, & t \ge t_i \\ 0, & \text{otherwise} \end{cases}$

In this case we have the following time variation of $u$.
$$
u_t = 
\begin{cases} 
u_0, & t < t_1 \\
\frac{u_0}{2}, & t_1 \le t < t_2 \\
\frac{u_0}{4}, & t \ge t_2
\end{cases}
$$

### User Interface (0.0.3)

There is a question of whether we should start with break-points or just jump to general log linear model. Then there is the related question of whether we should have a formula interface.

Thoughts:

* The break-point schedule provided as a table (as is currently done in MacPan) is intuitive and probably preferable if nothing more complex is required
* 

### Data Structure (0.0.3)

In the non-time-varying case of v0.0.2, we have scalar valued parameters. These parameters are constant in simulation time. We now move to time-varying parameters. Such parameters have their own parameters that determine a model of time-variation. These latter parameters get transformed to produce a time series of parameter values of length equal to the number of time steps. One simple thing to do would be to put these time series into the parameter vector, and when parameters are accessed use the index `spi + t` where `spi` is the index into the `state_param` vector that picks out the first parameter in the time series and `t` is the current time step. I'm a little worried that this could have us jumping around to different memory locations too much, so I will need to discuss with Weiguang and Ben.

* `tvi_spi`: vector of indices for each time varying factor into the `spi` vector from [version 0.0.1](https://canmod.net/misc/flex_specs#v0.0.1)
* `n_breaks`: vector of the number of time breaks for each time varying factor
* `t_breaks`: vector of indices locating all time breaks for all time varying factors, organized such that time indices associated with the same factor are grouped together and time indices are all ascending

The basic idea is to expand the parameter vector to represent time variation. Consider the case where there is a single baseline transmission rate, `beta0`.

```{r, eval=FALSE}
params = c(..., beta0, ...)
```

Now if `beta0` changes throughout the simulation, we expand the parameter vector. For example, if the transmission rate changes at time-steps 10 and 14, we would have the following expanded parameter vector.

```{r, eval=FALSE}
params = c(..., beta0, beta_t_10, beta_t_14, ...)
```

It could even be that there is a different transmission rate for every time step.

For each time-varying parameter we need to have the following vectors, each of which have length given by the number of different values for the parameter (three in the example above).

* `tvpi` gives indices into the parameter vector such that `params[tvpi]` returns all elements of the parameter vector associated with a single scalar-valued epidemiological parameter that is varying in time
   * Note that when the state variable and parameter vectors are concatenated, an offset is required: `state_param[tvpi + num_state_vars]`
* `bp` gives the indices of the break-points, or time steps at which the parameter changes

## v0.0.2

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.2)

Iterated updates of the state vector.

### Assumptions (0.0.2)

1. No parameter varies throughout a simulation
2. Simple $dt = 1$ simulation (i.e. unit time step, `do_exponential == FALSE`, and `do_hazard == FALSE`)
4. No stochasticity
5. `MP_badsum_action = 'ignore'`
6. No updates optimization
7. No model structure (e.g. vaccination, age-structure, testing)
8. [Assumptions 2-4 from 0.0.1](#assumptions-0.0.1)

### Mathematical Description (0.0.2)

Let $s$ be the state vector and $M$ be the rate matrix. Define the flows matrix, $F$, to have the same dimensions as $M$. The elements of $F$ are given by the following.

$$
F_{ij} = M_{ij} s_i
$$

Let $f_{\text{in}}$ and $f_{\text{out}}$ be the inflow and outflow vectors, given by the column sums and row sums of $F$ respectively. If the use specifies some states as being parallel accumulators, then the columns associated with those special states are removed from $F$ before the row sums are taken to compute $f_{\text{out}}$.

With these definitions in place the state vector update at each iteration is given by the following.

$$
s \to s - f_{\text{out}} + f_{\text{in}}
$$
Here is a summary of the stages of a single simulation step under this model.

1. Update the rate matrix following [version 0.0.1](#v0.0.1)
2. Compute the flow matrix
3. Compute the inflow vector
4. Compute the outflow vector, making sure to ignore the flow matrix columns associated with parallel accumulators
5. Produce a new state by subtracting the outflows and adding the inflows
6. Save every $k$th state vector to be returned

### User Interface (0.0.2)

In addition to the [interface elements specified in 0.0.1](#user-interface-0.0.1), the user needs to provide some additional information. We need to provide a character vector of regex patterns with which to find the indices of the parallel accumulators amongst the state names (e.g. `r c("X", "N", "P", "V")`). For example, one way to provide such a vector to an existing model would be the following.
```{r, eval=FALSE}
model = add_parallel_accumulators(model, c("X", "N", "P", "V"))
```

The user must also be able to specify the number of state vector updates and the frequency (i.e. $k$ defined above in the Mathematical Description) with which state vectors are saved.

### Data Structure (0.0.2)

The following pieces of information need to be added to those described in [Data Structure (0.0.2)](#data-structure-0.0.2) in order to make state vector updates.

* Modified copies of the following integer vectors described in [0.0.1](#data-structure-0.0.1): `spi`, `modifier`, `from`, `to`, `count`
   * These copies will only contain indices necessary for updating the rate matrix elements that could potentially change at each simulation step
   * Currently this will include non-zero rate matrix elements that depend on at least one state variable (those that depend on parameters only will not need to be updated given that this version of the spec does not allow for time-varying parameters)
* A vector, `par_accum_indices` of indices into the columns of the flows matrix, identifying the states that are parallel accumulators
* The number of state vector updates to simulate
* State saving frequency

## v0.0.1

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.1)

Update the non-zero elements of a rate matrix on the `TMB`/`C++` side using a restricted set of operations (complements, inverses, sums, and products). The update formula must be specified separately for each non-zero element.

### Assumptions (0.0.1)

1. The state vector is not actually updated, making this a more-or-less useless spec (but it provides a good 'warm-up' and sanity check)
2. A `param_pansim` and a `state_pansim` object exists or can be constructed
3. If `make_state` is used to create the `state_pansim` object, `vaxify`, `ageify`, and `testify` are all set to `FALSE`
4. There is no model structure (e.g. vaccination, age-structure, testing)

### Mathematical Description (0.0.1)

Any element, $x$, of either the parameter or state vector can be used to define a _factor_ in one of the following three forms.

* Identity: $x$
* Complement: $1-x$
* Inverse: $1/x$

We collect these user-defined factors into a factor vector, $y$. Factors can be repeated in $y$ if required. Any number of factors can be multiplied together using `*` to produce a _product_. Any number of factors and products can be added together using `+`.

There is a higher level nested structure associated with the factor vector, $y$.

* All factors associated with the, $i$th, non-zero rate matrix element, $M_{(i)}$, are grouped together in a contiguous block
* Within the $i$th block, all factors associated with the $j$th product ($j = 1 ... n_i$) in that block are grouped together in a contiguous sub-block
* Within the $i,j$th sub-block, all factors are given an index, $k = 1 ... m_{ij}$

With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression.

$$
M_{(i)} = \sum_{j=1}^{n_i} \prod_{k=1}^{m_{ij}} y_{ijk}
$$

where $y_{ijk}$ is the $k$th factor associated with the $j$th product associated with the $i$th non-zero rate matrix element.

### User Interface (0.0.1)

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter-dependence and/or state-dependence of a single non-zero rate matrix element. The standard `McMasterPandemic` introductory example model can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(params, state)
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m))
  %>% add_tmb_indices()
)
```

The first step, `init_model`, in this pipeline initializes the compartmental model by specifying `state_params` and `state_pansim` objects containing the parameters and state variables respectively.

Each subsequent call to `add_rate` defines the dependence of a single non-zero rate matrix element on parameters and state variables. When used in a pipeline, the `add_rate` function takes three arguments.

1. `from` -- character string describing the state associated with the row of the rate matrix
2. `to` -- character string describing the state associated with the column of the rate matrix
3. `formula` -- one-sided model formula defining the dependence based on symbols associated named parameter and state vectors
   * Any single parameter or state variable name, `x`, can be placed in parentheses to produce a _factor_ in the following three ways
      * Identity: `(x)`
      * Complement: `(1-x)`
      * Inverse: `(1/x)`
   * Factors can be multiplied together with the `*` operator to produce a _product_
   * Products and factors can be added together with the `+` operator to produce a non-zero rate matrix element

The final step of the pipeline adds the indices to be passed to `TMB`/`C++` that are described in the [Data Structure](#data-structure-0.0.1) section below.

### Data Structure (0.0.1)

The object created by the pipeline in the [User Interface](#user-interface-0.0.1) section above must contain at a minimum the following seven objects.

1. The initial value of a `state_pansim` object representing the vector, `state`, containing the state variables
2. The initial value of a `param_pansim` object representing the vector, `params`, containing the parameters
3. An integer vector, `spi`, of 1-based indices into a concatenation, `state_param`, of `state` and `param`
   * The ordering of the elements of `state_param` is arbitrary because several integer vectors defined below contain indices into these elements for book-keeping purposes on the `TMB`/`C++` side
   * However, typically it will make sense to at least keep the state variables together and the parameters together
   * On the `R` side, `spi` has the property that `state_param[spi]` returns a vector of state variables and parameters in the order in which they occur in the factor vector defined above in the Mathematical Description section
   * Note that `state_param[spi]` does not return the factor vector itself -- to get the factor vector from `state_param[spi]` you would need to modify some of the elements by taking their complements and inverses
4. An integer vector, `modifier`, of the same length as `spi`
   * Each element of `modifier` corresponds to a factor, as defined above in the Mathematical Description
   * These elements bit-wise encode several pieces of information
      * What elements of `state_param[spi]` need to transformed by complements or inverses
      * Whether complements or inverses should be used for those elements that need to be transformed
      * What elements of `state_param[spi]` need to be multiplied together to take products
   * The binary expansion of these elements can each be represented with three bits, with each bit encoding different information
      * The left-most bit is `1` if the corresponding factor is the first in a product that needs to be added to a previous product, and `0` otherwise
      * The middle bit is `1` if the corresponding factor requires a complement and `0` otherwise
      * The right-most bit is `1` if the corresponding factor requires an inverse and `0` otherwise
5. An integer vector, `from`, of 1-based indices, the $i$th element of which points to the row of the $i$th non-zero rate matrix element
6. An integer vector, `to`, of 1-based indices, the $i$th element of which points to the column of the $i$th non-zero rate matrix element
7. An integer vector, `count`, the $i$th element of which gives the number of factors used to calculate the $i$th non-zero rate matrix element
   * In terms of the Mathematical Description above, the elements of `count` store these sums $\sum_{j=1}^{n_i}m_{ij}$
