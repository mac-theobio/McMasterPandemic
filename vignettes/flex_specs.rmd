---
title: "Flexible Compartmental Modelling Specifications"
author: "Steve Walker, Weiguang Guan, Ben Bolker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flexible Compartmental Modelling Specifications}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

[McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic) is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This refactoring will be done incrementally by implementing a series of versioned specifications that define each step. This document outlines these specifications, and provides a roadmap for planning future specifications.

We are using semantic versioning https://semver.org/ to provide versions for the specs themselves. All versions of the spec that have not been implemented in a released version of the McMasterPandemic R package have major version 0 (e.g. 0.x.y, https://semver.org#spec-item-4) -- currently all of them.

We use `r options(macpan_spec_version = '0.0.1')`

Each frozen version of the spec must contain the following five sections.

* _New Capabilities_ -- very short summary; refer to previous versions for background
* _Assumptions_ -- known assumptions that can help users/developers understand if this version will suite their needs
* _Mathematical Description_ -- precise definition of the new or changed features of the model; refer to previous versions for definitions being reused
* _User Interface_ -- short description and example of the user interface in `R` for model specification
* _Data Structure_ -- definition of the data structure to be passed from `R` to `TMB`/`C++` that stores the model structure

# Table of Contents

## Released Versions

The specs for the following versions are released, which means that they will not change.

* [0.0.1 -- Simple rate matrix updates](#v0.0.1)

## Future Versions

The specs for the following versions are unreleased, which means that they will probably change and are actively being developed. These versions also serve as a roadmap.

* [0.0.2 -- Simulation (iterated state variable updates)](#v0.0.2)
* [0.0.3 -- Time-varying parameters](#v0.0.3)
* [0.0.4 -- Model structure](#v0.0.4)
* [0.0.5 -- Condensation and calibration](#v0.0.5)
* [0.0.6 -- Hazard and ODE simulation](#v0.0.6)
* [0.0.7 -- Stochasticity](#v0.0.7)

# v0.0.7

## New Capabilities 0.0.7

Stochasticity.

# v0.0.6

## New Capabilities 0.0.6

Hazard and exponential simulation.

# v0.0.5

## New Capabilities 0.0.5

Condensation and calibration.

# v0.0.4

## New Capabilities (0.0.4)

Model structure (e.g. vaccination, age, testing) by modifying the user interface to accept matrix/vector inputs. There are two ways to do this: (1)  expand the inputs to fit into the scalar models below or (2) pass the inputs directly to `TMB`/`C++` and modify the code on that side.

# v0.0.3

## New Capabilities (0.0.3)

Time-varying parameters.  There is a question of whether we should start with break-points or just jump to general log-linear model.

# v0.0.2

## New Capabilities (0.0.2)

Iterated updates of the state vector.

## Assumptions (0.0.2)

1. No parameter varies throughout a simulation
2. `do_exponential == FALSE`, `do_hazard == FALSE`
4. No stochasticity
5. `MP_badsum_action = 'ignore'`
6. Unit time step, `dt = 1`
7. Assumptions 2-4 from 0.0.1

## Mathematical Description (0.0.2)

Let $s$ be the state vector and $M$ be the rate matrix. Define the flows matrix, $F$ to have the same dimensions as $M$. The elements of $F$ are given by the following.

$$
F_{ij} = M_{ij} s_i
$$

Let $f_{\text{in}}$ and $f_{\text{out}}$ be the inflow and outflow vectors, given by the column sums and row sums of $F$ respectively. If the use specifies some states as being parallel accumulators, then the columns associated with those special states are removed from $F$ before the row sums are taken to compute $f_{\text{out}}$.

With these definitions in place the state vector update at each iteration is given by the following.

$$
s \to s - f_{\text{out}} + f_{\text{in}}
$$

## User Interface (0.0.2)

In addition to the interface elements specified in 0.0.1, the user needs to specify some additional arguments. We need a character vector of regex patterns with which to find the indices of the parallel accumulators amongst the state names (e.g. `r c("X", "N", "P", "V")`). We also need to specify the number of iterative state vector updates.

## Data Structure (0.0.2)

The following additional pieces of information need to be provided in order to make state vector updates, in addition to rate matrix updates.

* A vector, `si` of indices into `state_param` such that `state_param[si]` returns the state vector
   * A good choice for `si` is `1:N` where `N` is the number of state variables, but this is only possible if the first `N` elements of `state_param` are the state variables and they are in the same order as the rows and columns of the rate matrix
* A vector, `ai` of indices into the rows (or equivalently columns) of the rate matrix, identifying the states that are parallel accumulators
* The number of iterations of the state vector

# v0.0.1

## New Capabilities (0.0.1)

Update the elements of a rate matrix on the `TMB`/`C++` side using a restricted set of operations (complements, inverses, sums, and products). The update formula must be specified separately for each non-zero element.

## Assumptions (0.0.1)

1. The state vector is not actually updated, making this a more-or-less useless spec (but it provides a good 'warm-up' and sanity check)
2. A `param_pansim` and a `state_pansim` object exists or can be constructed
3. If `make_state` is used to create the `state_pansim` object, `vaxify`, `ageify`, and `testify` are all set to `FALSE`
4. The results of running the parameter and state vectors through `make_ratemat` are stored

## Mathematical Description (0.0.1)

Any element, $x$, of either the parameter or state vector can be used to define a _factor_ in one of the following three forms.

* Identity: $x$
* Complement: $1-x$
* Inverse: $1/x$

We collect these user-defined factors into a factor vector, $y$. Factors can be repeated in $y$ if required. Any number of factors can be multiplied together using `*` to produce a _product_. Any number of factors and products can be added together using `+`.

There is a higher level nested structure associated with the factor vector, $y$.

* All factors associated with the, $i$th, non-zero rate matrix element, $M_{(i)}$, are grouped together in a contiguous block
* Within the $i$th block, all factors associated with the $j$th product ($j = 1 ... n_i$) in that block are grouped together in a contiguous sub-block
* Within the $i,j$th sub-block, all factors are given an index, $k = 1 ... m_{ij}$

With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression.

$$
M_{(i)} = \sum_{j=1}^{n_i} \prod_{k=1}^{m_{ij}} y_{ijk}
$$

where $y_{ijk}$ is the $k$th factor associated with the $j$th product associated with the $i$th non-zero rate matrix element.

## User Interface (0.0.1)

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter-dependence and/or state-dependence of a single non-zero rate matrix element. The standard `McMasterPandemic` introductory example model can be defined as follows.

```{r, eval=FALSE}
rs = mk_ratemat_struct(
  rate("E", "Ia", ~ (alpha) * (sigma)),
  rate("E", "Ip", ~ (1 - alpha) * (sigma)),
  rate("Ia", "R", ~ (gamma_a)),
  rate("Ip", "Im", ~ (mu) * (gamma_p)),
  rate("Ip", "Is", ~ (1 - mu) * (gamma_p)),
  rate("Im", "R", ~ (gamma_m)),
  rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)),
  rate("Is", "ICUs", ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s)),
  rate("Is", "ICUd", ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s)),
  rate("Is", "D", ~ (nonhosp_mort) * (gamma_s)),
  rate("ICUs", "H2", ~ (psi1)),
  rate("ICUd", "D", ~ (psi2)),
  rate("H2", "R", ~ (psi3)),
  rate("H", "R", ~ (rho)),
  rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s)),
  rate("S",  "E", ~
         (Ia) * (beta0) * (1/N) * (Ca) +
         (Ip) * (beta0) * (1/N) * (Cp) +
         (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
         (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m))
)
```

Each call to `rate` defines the dependence of a single non-zero rate matrix element on parameters and state variables. The `rate` function takes three parameters.

* `from` -- symbol describing the state associated with the row of the rate matrix
* `to` -- symbol describing the state associated with the column of the rate matrix
* `formula` -- one-sided model formula defining the dependence based on symbols associated named parameter and state vectors
   * Any single parameter or state variable name, `x`, can be placed in parentheses to produce a _factor_ in the following three ways
      * Identity: `(x)`
      * Complement: `(1-x)`
      * Inverse: `(1/x)`
   * Factors can be multiplied together with the `*` operator to produce a _product_
   * Products and factors can be added together with the `+` operator to produce a non-zero rate matrix element

## Data Structure (0.0.1)

```{r, echo=FALSE}
to_tmb_eg = list(
  from = c(2L, 2L, 3L, 4L, 4L, 5L, 6L, 6L, 6L, 6L, 9L, 10L, 8L, 7L, 6L, 1L), 
  to = c(3L, 4L, 12L, 5L, 6L, 12L, 7L, 9L, 10L, 11L, 8L, 11L, 12L, 12L, 13L, 2L), 
  count = c(2L, 2L, 1L, 2L, 2L, 1L, 3L, 4L, 4L, 2L, 1L, 1L, 1L, 1L, 3L, 18L), 
  spi = c(20L, 21L, 20L, 21L, 22L, 28L, 25L, 28L, 25L, 23L, 31L, 34L, 24L, 31L, 
          34L, 35L, 24L, 31L, 34L, 35L, 24L, 31L, 24L, 36L, 37L, 38L, 26L, 31L,
          34L, 24L, 3L, 15L, 29L, 16L, 4L, 15L, 29L, 17L, 5L, 15L, 29L, 18L, 
          32L, 6L, 15L, 29L, 19L, 32L), 
  modifier = c(0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 
               0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 4, 0, 2, 0, 4, 0, 2, 0, 1, 4, 
               0, 2, 0, 1))
```


The data structure must contain the following six objects.

* The initial value of a vector, `state_param`, containing the state variables and parameters
   * The ordering of the elements of `state_param` is arbitrary because several integer vectors defined below contain indices into these elements for book-keeping purposes on the `TMB`/`C++` side
   * However, typically it will make sense to at least keep the state variables together and the parameters together
* An integer vector, `spi`, of 1-based indices into `state_param`
   * On the `R` side, `spi` has the property that `state_param[spi]` returns a vector of state variables and parameters in the order in which they occur in the factor vector defined above in the Mathematical Description section
   * Note that `state_param[spi]` does not return the factor vector itself -- to get the factor vector from `state_param[spi]` you would need to modify some of the elements by taking their complements and inverses
* An integer vector, `modifier`, of the same length as `spi`
   * Each element of `modifier` corresponds to a factor, as defined above in the Mathematical Description
   * These elements bit-wise encodes several pieces of information
      * What elements of `state_param[spi]` need to transformed by complements or inverses
      * Whether complements or inverses should be used for those elements that need to be transformed
      * What elements of `state_param[spi]` need to be multiplied together to take products
   * The binary expansion of these elements can each be represented with three bits, with each bit encoding different information
      * The left-most bit is `1` if the corresponding factor is the first in a product that needs to be added to a previous product, and `0` otherwise
      * The middle bit is `1` if the corresponding factor requires a complement and `0` otherwise
      * The right-most bit is `1` if the corresponding factor requires an inverse and `0` otherwise
* An integer vector, `from`, of 1-based indices, the $i$th element of which points to the row of the $i$th non-zero rate matrix element
* An integer vector, `to`, of 1-based indices, the $i$th element of which points to the column of the $i$th non-zero rate matrix element
* An integer vector, `count`, the $i$th element of which gives the number of factors used to calculate the $i$th non-zero rate matrix element
   * In terms of the Mathematical Description above, the elements of `count` store these sums $\sum_{j=1}^{n_i}m_{ij}$
