---
title: "Flexible Compartmental Modelling Specifications"
author: "Steve Walker, Weiguang Guan, Ben Bolker"
date: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flexible Compartmental Modelling Specifications}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

[![Live
Version](https://img.shields.io/static/v1.svg?label=Updated&message=`r Sys.Date()`&color=blue)](https://canmod.net/misc/flex_specs)

[McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic) is a
modelling tool that was rapidly developed to provide timely insights
into the Covid-19 Pandemic in Canada. We are currently refactoring this
tool so that it is faster and more general. This refactoring will be
done incrementally by implementing a series of versioned specifications
that define each step. This document outlines these specifications, and
provides a roadmap for planning future specifications.

# Table of Contents

-   [Versioning and
    Lifecycle](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)
-   [Version
    Summary](https://canmod.net/misc/flex_specs#version-summary)
-   [Version
    Descriptions](https://canmod.net/misc/flex_specs#version-descriptions)

# Versioning and Lifecycle

We are using semantic versioning <https://semver.org/> to provide
versions for the specs. All versions of a spec that have not been
implemented in a released version of the McMasterPandemic R package have
major version 0 (e.g. 0.x.y, <https://semver.org#spec-item-4>) --
currently all of them. Although none of these specs are released, they
are being experimentally implemented on the [TMB branch of
McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic/tree/tmb),
with R-side code
[here](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/R/tmb.R).
There is a global option, `MP_flex_spec_version`, that is used by this
`R` code to control what spec version is being assumed by the
`TMB`/`C++` code. This helps in
[testing](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/tests/testthat/test-tmb.R)
as well. `C++` files that implement various spec versions are currently
being placed
[here](https://github.com/mac-theobio/McMasterPandemic/tree/tmb/inst/tmb).

Spec versions have three life cycle stages: frozen, experimental, and
archived. If a frozen version needs clarification or updating, this
clarification must be done by linking to a subsequent version that
addresses the issue(s). Each frozen version of the spec must contain the
following five sections.

-   *New Capabilities* -- very short summary; refer to previous versions
    for background
-   *Assumptions* -- known assumptions that can help users/developers
    understand if this version will suite their needs
-   *Mathematical Description* -- precise definition of the new or
    changed features of the model; refer to previous versions for
    definitions being reused
-   *User Interface* -- short description and example of the user
    interface in `R` for model specification
-   *Data Structure* -- definition of the data structure to be passed
    from `R` to `TMB`/`C++` that stores the model structure

# Version Summary

## Frozen Versions

The specs for the following versions are frozen, which means that they
will not change.

-   [0.0.1 -- Simple rate matrix updates](#v0.0.1)
-   [0.0.2 -- Simulation (iterated state variable updates)](#v0.0.2)
-   [0.0.4 -- Piece-wise constant exogenous time-variation of
    parameters](#v0.0.4)
-   [0.0.5 -- Hazard simulation](#v0.0.5)
-   [0.0.6 -- Updates of time-varying parameters from the initial
    parameters on the `C++` side](#v0.0.6)

## Experimental Versions

The specs for the following versions are being actively developed and
modified. These versions also serve as a roadmap. Note that version
numbers of experimental versions can change without warning.

-   [0.1.0 -- Model structure](#v0.1.0)
-   [0.1.1 -- Make state and calibrate time-varying
    multipliers](#v0.1.1)
-   [0.1.2 -- Log-linear exogenous time-variation of
    parameters](#v0.1.2)
-   [0.2.0 -- Condensation and calibration](#v0.2.0)
-   [0.2.1 -- ODE simulation](#v0.2.1)
-   [0.2.2 -- Stochasticity](#v0.2.2)
-   [0.3.0 -- Endogenous time-variation of parameters](#v0.3.0)
-   [0.4.0 -- Time steps not equal to one](#0.4.0)
-   [1.0.0 -- Version One](#1.0.0)

## Archived Versions

The specs for archived versions are frozen but no longer respected by
the `McMasterPandemic` `R` package and/or its test framework. Archived
versions cannot be ignored because Frozen and Experimental versions may
still reference them.

-   [0.0.3 -- Piece-wise constant exogenous time-variation of parameters
    (first attempt)](#v0.0.3)

# Version Descriptions

## v1.0.0

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

Here we describe what we are working towards. This will change regularly, but the goal is to have a clear, succinct, and accurate description of refactored McMasterPandemic at the same time that it is ready.

### Mathematical Description (1.0.0)

#### State Variable Simulation

Top-level algorithm:

1. Make state
2. Update sums of state variables and parameters
3. Make rate matrix
4. Add initial state to the report
5. Add initial structural (i.e. non-zero) elements of the rate matrix to the report
6. Run the simulation loop for `end_date - start_date` iterations, where the date difference is taken in units of days (e.g. `"2021-10-12" - "2021-10-10" = 2`)
7. Compute and return the objective function

Make state algorithm:

Simulation loop algorithm:

1. Update the state vector
2. Update the time-varying parameters
3. Update sums of state variables and parameters
4. Update rate matrix
5. Add updated state variable to the report
6. Add updated structural (i.e. non-zero) elements of the rate matrix to the report

Update time-varying parameters algorithm:

1. 

Objective function algorithm:

## v0.4.0

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.4.0)

Time steps not equal to one.

## v0.3.0 {#v0.3.0}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.3.0)

Endogenous time-variation of parameters.

## v0.2.2 {#v0.2.2}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.2)

Stochasticity.

## v0.2.1 {#v0.2.1}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.1)

ODE (i.e. exponential) simulation.

## v0.2.0 {#v0.2.0}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.0)

Condensation and calibration.

## v0.1.2 {#v0.1.2}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.1.2)

Log-linear exogenous time-variation of parameters.

### Mathematical Description (0.1.2)

Such parameters have their own parameters that determine a model of
time-variation. These latter parameters get transformed to produce a
time series of parameter values of length equal to the number of time
steps. One simple thing to do would be to put these time series into the
parameter vector, and when parameters are accessed use the index
`spi + t` where `spi` is the index into the `state_param` vector that
picks out the first parameter in the time series and `t` is the current
time step. I'm a little worried that this could have us jumping around
to different memory locations too much, so I will need to discuss with
Weiguang and Ben.

$$
\log(u) = \log(u_0) + Xv
$$ where $u$ is a vector of length $T$, the number of time steps, $u_0$
is a scalar parameter, $v$ is a vector of length $D < T$ that
parameterizes the model of time variation, and $X$ is a $T$-by-$D$
matrix of constant columns (e.g. indicator variables, spline bases).
Note that logs of vectors are taken element-wise.

$$
\log(u_t) = \log(u_0) + \sum_{i=1}^Dx_{ti}v_i
$$ $$
u_t = u_0 \prod_{i=1}^D\exp\left(x_{ti}v_i\right)
$$ For example:

-   $D=2$ breakpoints
-   $v_1 = v_2 = \log\left(\frac{1}{2}\right) \approx -0.69$
-   $x_{ti} = \begin{cases} 1, & t \ge t_i \\ 0, & \text{otherwise} \end{cases}$

In this case we have the following time variation of $u$. $$
u_t = 
\begin{cases} 
u_0, & t < t_1 \\
\frac{u_0}{2}, & t_1 \le t < t_2 \\
\frac{u_0}{4}, & t \ge t_2
\end{cases}
$$

## v0.1.1 {#v0.1.1}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.1.1)

This is a very big 'patch'.  The motivation for it is to get a first release that is potentially useful to PHAC. This requires three enhancements.

-   Generalization of the definition of the outflow vector
-   Construct the state vector from the parameter vector at the
    beginning of each simulation run
-   Move `tv_mult` to the parameters so that we can calibrate them if we
    need to do so

### Mathematical Description (0.1.1)

#### Generalization of Outflow Vector

Let $f_i^{(out)}$ be the $i$th element of the outflow vector, which is computed as follows. 
$$
f_i^{(out)} = \sum_{j \in \Omega_i}F_{ij}
$$

Where $\Omega_i$ is a subset of the indices into the state vector. Typically there are only a small number of unique index sets, with one $\Omega_i$ for many values of $i$ -- for this reason the data structure for these indices only need to track each unique index set.

We can express the previous definition of the outflow vector (TODO: link to previous definition) in the terms of this generalization as a constant $\Omega = \Omega_i, \forall i$.

#### Make State Vector

In previous spec versions, the `C++` side needs to get the initial state vector directly from R. The difficulty with this strategy is that the initial state vector depends on the parameter vector, so when a new parameter vector gets updated in an optimization or ensemble run it becomes necessary to drop back to R causing a substantial performance bottleneck. So here we add the ability to create the initial state vector from the parameter vector in `C++`.

What follows is a detailed description of the procedure, which makes reference to new items in the data structure (see Data Structure below).

0. We first check to see if a state vector has been passed -- if not, do the following steps to create a new state vector
1. Initialize two state vectors with all zeros (note that this is in contrast to the current situation where `state` is passed in -- now `n_states` will be passed in as an integer giving the number of state variables)
    * `state` -- initializing state vector for the full non-linearized model
    * `lin_state` -- initializing state vector for the linearized model
2. Make a copy (`lin_params`) of the parameter vector (`params`)
3. Replace some user-specified elements of `lin_params` with user supplied constant values (`lin_param_vals`, `lin_param_count`, `lin_param_idx` -- these can be found in `model$tmb_indices$linearized_params`)
4. Replace some user-specified elements of `lin_state` with elements of `lin_params` (`df_state_par_idx`, `df_state_count`, `df_state_idx` -- these can be found in `model$tmb_indices$disease_free`)
5. Compute the Jacobian matrix (`jac`), which requires the following steps in a function that takes `lin_state` and returns an updated `lin_state`
    - Create a rate matrix (`lin_ratemat`) from `lin_state` and `lin_params` using the existing `make_ratemat_indices`
    - Create a flow matrix (`lin_flow`) from `lin_state` and `lin_ratemat`
    - Create inflow vector (`lin_inflow`) from `lin_flow` by taking column sums
    - Create outflow vector (`lin_outflow`) from `lin_flow` by the method above -- Generalization of Outflow Vector (`linearized_outflow_row_count`, `linearized_outflow_col_count`, `linearized_outflow_rows`, `linearized_outflow_cols`)
    - Update `lin_state` using `lin_inflow` and `lin_outflow`
6. Remove certain user-defined rows, columns, and elements from `jac` and `lin_state` to create a new vector `eigvec` (`all_drop_eigen_idx` -- can be found in `model$tmb_indices$initialization_mapping`)
7. Compute the dominant eigenvector, `eigvec` of `jac`
8. Remove elements of `eigvec` to create `eig_infected` (`eigen_drop_infected_idx` -- can be found in `model$tmb_indices$initialization_mapping`)
9. Normalize `eig_infected` to have elements that sum to one
10. Update `state[all_to_infected_idx] = eig_infected * param[infected_idx]` (`infected_idx` can be found in `model$tmb_indices$initial_population`)
11. Update `state[susceptible_idx] = (1/susceptible_idx.size()) * (param[total_idx] - param[infected_idx])` (`infected_idx` and `total_idx` can be found in `model$tmb_indices$initial_population`)

Future optimization: we should cache the eigenvector in the ADFun so that fewer iterations are required in the power method and avoid needing to make `lin_state` from scratch every update of the parameters.

#### Calibrate Time Varying Multipliers



### Data Structure (0.1.1)

#### Generalization of Outflow Vector

Objects of class `flexmodel` contains a new element called `tmb_indices$outflow`, with the following elements
- `row_count` -- 
- `col_count` --
- `rows` -- 
- `cols` -- 

These indices encode information in the $\omega_i$ index sets (see Mathematical Description above).

This `outflow` item means that `par_accum_indices` is no longer required. Given that we do not need to worry about back compatibility yet, it will be dropped from this and all future spec versions.

#### Make State Vector

Objects of class `flexmodel` contains the following new elements.

-   `linearized_params` -- indices to update some elements of `lin_param` before computing the Jacobian of the linearized model
    - `lin_param_vals` -- values used to fill the elements of `lin_param`
    - `lin_param_count` -- the number of elements of `lin_param` that will be updated with each value in `lin_param_vals`
    - `lin_param_idx` -- indices of `lin_param` to update
-   `disease_free` -- indices to initialize `lin_state` to be nearly disease-free, by setting some of its elements equal to some elements of `lin_param`
    - `df_state_par_idx` -- indices of `lin_param` used to fill the elements of `lin_state`
    - `df_state_count` -- the number of elements of `lin_state` that will be updated with each parameter identified by `df_state_par_ix`
    - `df_state_idx` -- indices of `lin_state` to update
-   `linearized_outflow` -- same as `outflow` but for the linearized model
-   `initialization_mapping` -- indices into various subsets of the state vector and eigenvector that could be useful for initializing the state -- see justification below this list
    - `all_to_eigen_idx` -- indices into `state` and `lin_state` for identifying states in `eigvec`
    - `all_to_infected_idx` -- indices into `state` and `lin_state` for identifying states in `eig_infected` 
    - `eigen_to_infected_idx` -- indices into `eigvec` for identifying states in `eig_infected`
    - `all_drop_eigen_idx` -- indices into `state` and `lin_state` for identifying states not in `eigvec`
    - `all_drop_infected_idx` -- indices into `state` and `lin_state` for identifying states not in `eig_infected`
    - `eigen_drop_infected_idx` -- indices into `eigvec` for identifying states not in `eig_infected`
    - `susceptible_idx` -- indices into `state` and `lin_state` for identifying states associated with the initial susceptible population 
-   `initial_population` -- indices into the parameter vector for identifying the total number of individuals in the population and the initial total number of infected individuals in the population
    - `total_idx`
    - `infected_idx`

The justification for the `initialization_mapping` is given here.  One potential source of confusion in the above process is the need to keep track of the different subsets of states. To help clarify this point, there are conceptually three types of state vectors containing nested subsets of states.
1. `all_states` -- vectors containing all states 
2. `eigen_states` -- vectors containing all states of the linearized system that are included in the dominant eigenvector
3. `infected_states` -- vectors containing all infected states, which are `eigen_states` that will be initialized using corresponding elements in the eigenvector

To make life a little easier for development on the `C++` side we provide index vectors for converting between the three nested sets of states.
1. `all_to_eigen_idx`
2. `all_to_infected_idx`
3. `eigen_to_infected_idx`

And for completeness, in case it is useful, we also provide index vectors for dropping states from each kind of state vector.
1. `all_drop_eigen_idx`
2. `all_drop_infected_idx`
3. `eigen_drop_infected_idx`



## v0.1.0 {#v0.1.0}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.1.0)

We bump major versions here to start working on model structure (e.g.
vaccination, age, testing). We make two enhancements:

1.  Introduce a new `struc` object class that allows for symbolic
    manipulation of matrices and vectors of parameters and state
    variables when defining rate matrix elements
2.  The ability to refer to sums of state variables and parameters when
    defining expressions for rate matrix elements.

### Mathematical Description (0.1.0)

#### struc objects

#### Sums of state variables and parameters

Within each simulation iteration, a user-defined number of sums of state
variables and parameters are computed and stored immediately before the
rate matrix is updated.

### User Interface (0.1.0)

#### struc objects

As an example, the force of infection under the two-dose vaccination
model can be given by the following `struc` objects.

Start by getting a set of vaccination parameters and state variables.

```{r, echo=FALSE, message=FALSE}
library(McMasterPandemic)
library(dplyr)
```

Create a symbolic vector of I-state variables, with 4 base states by 5
vaccination categories = 20 variables.

```{r}
base_params <- read_params("PHAC.csv")
vax_params <- expand_params_vax(
  params = base_params,
  model_type = "twodose"
)
Istate = (McMasterPandemic:::expand_names(
  c('Ia', 'Ip', 'Im', 'Is'),   # = Icats
  attr(vax_params, 'vax_cat')) # = vax_cats
  %>% struc
)
as.matrix(Istate)
```

Create a vector of base transmission rates associated with each of the 4
base I-states.

```{r}
baseline_trans_rates =
  struc(
  'Ca',
  'Cp',
  '(1 - iso_m) * (Cm)',
  '(1 - iso_s) * (Cs)') *
  struc('(beta0) * (1/N)')
as.matrix(baseline_trans_rates)
```

Create a 5-by-5 block matrix of vaccine efficacies

```{r}
vax_trans_red = struc_block(struc(
  '1',
  '1',
  '(1 - vax_efficacy_dose1)',
  '(1 - vax_efficacy_dose1)',
  '(1 - vax_efficacy_dose2)'),
  row_times = 1, col_times = 5)
as.matrix(vax_trans_red)
```

And finally the force of infection vector, which looks like we really
need to introduce the capability for common factors.

```{r}
foi = kronecker(vax_trans_red, t(baseline_trans_rates)) %*% Istate
foi
```

#### Sums of state variables and parameters

Start with a basic example model.

```{r}
params <- read_params("ICU1.csv")
state <- make_state(params = params)
M <- McMasterPandemic::make_ratemat(state, params, sparse = TRUE)
test_model <- init_model(
    params, state,
    start_date = "2021-09-09", end_date = "2021-10-09"
)
```

Then we define sums of state variables and parameter vectors. Here we
add the sum of the `I` states and of the `ICU` states using regular
expressions and just a list of state names.

```{r}
test_model = (test_model
  %>% add_state_param_sum(sum = "Isum", summands = "^I[a-z]")
  %>% add_state_param_sum(sum = "ICUsum", summands = c("ICUs", "ICUd"))
)
```

Then we can just proceed as we normally would, but with the option to
refer to these sums (this is not meant to reflect real epidemiology, but
to illustrate the interface).

```{r}
test_model = (test_model
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma) * (1 / Isum))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho) / (1 / ICUsum))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S", "E", ~
                 (Ia) * (beta0) * (1 / N) * (Ca) +
                 (Ip) * (beta0) * (1 / N) * (Cp) +
                 (Im) * (beta0) * (1 / N) * (Cm) * (1 - iso_m) +
                 (Is) * (beta0) * (1 / N) * (Cs) * (1 - iso_s))
  %>% add_parallel_accumulators(c("X", "N", "P", "V"))
  %>% add_tmb_indices()
)
```

And here are the indices that are relevant to the tracking of sums of
state variables and parameters.

```{r}
test_model$tmb_indices$sum_indices
```

We describe these below.

### Data Structure (0.1.0)

#### struc objects

#### Sums of state variables and parameters

We introduce three new index/count vectors.

-   `sumidx` -- indices, locating the variable to store each sum, into
    the `state_param` vector defined in version 0.0.1
-   `sumcount` -- vector containing the number of summands required for
    each sum
-   `summandidx` -- indices, locating the summands, into the
    `state_param` vector

## v0.0.6 {#v0.0.6}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.6)

Updates of time-varying parameters from the initial parameters on the
`C++` side. This is really a patch of 0.0.4, which didn't work for
calibration because it required updating the objective function (or its
environment?) at every iteration of the optimizer. It is just easier to
do it on the `C++` and we need to do this anyways.

## v0.0.5 {#v0.0.5}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.5)

1.  Hazard simulation
2.  Returning the time-varying rate matrix elements from `C++` to `R` so
    that they can be included in the results of `run_sim`

### Mathematical Description (0.0.5)

Define the sums of the rows of the rate matrix. $$
r_i = \sum_{j=1}^n M_{ij}
$$ Define the elements of a vector of exponentiated row sums $$
\rho_i = \exp(-r_i)
$$

Define the elements of a normalized state vector. $$
\tilde{s}_i = \begin{cases}
0 & r_i = 0 \\
\frac{s_i}{r_i} & \text{otherwise}
\end{cases}
$$ With these definitions we can define the modified flow matrix. $$
F_{ij} = \begin{cases}
M_{ij}\tilde{s}_i(1-\rho_i) & i \ne j \\
0 & \text{otherwise}
\end{cases}
$$ This modified flow matrix can now be used in the same way as the
unmodified flow matrix to produce state variable updates following spec
version 0.0.2.

### User Interface (0.0.5)

A Boolean argument needs to be added to the interface, indicating
whether or not the hazard-based flow matrix is used rather than the
simple flow matrix.

### Data Structure (0.0.5)

The data structure is equivalent to 0.0.4.

## v0.0.4 {#v0.0.4}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

We begin with simple piece-wise constant time-variation. *Piece-wise
constant* means that each time-varying parameter is associated with a
sequence of break-points at which the value of the parameter changes --
at all other times the parameter is constant. We plan to relax the
*piece-wise constant* restriction in later versions.

### New Capabilities (0.0.4)

Patch of the spec from 0.0.3 on piece-wise constant time-varying
parameters.

### Data Structure (0.0.4)

-   *update_indices* (**removed**): a second set of *from* *to*, etc for
    need-to-update elements proposed in spec 0.0.2 is removed in this
    proposal because the newly introduced *upateidx* provides the
    information needed.
-   *upateidx* (**added**): a vector of indices into vectors *from*,
    *to*, and *count* of those elements in the rate matrix that need to
    be updated. It includes the indices of the elements that depend on
    either the state vector (0.0.2), or time-varying parameters (0.0.3
    or 0.0.4), or both. At each simulation step, we will update only
    those elements specified by *updateidx*. The drawback of this design
    is that elements that only depends on piece-wise parameters (0.0.3)
    are updated at each step although they only need to be updated at
    certain breaks.
-   *breaks* (**added**): vector of all the breaks.
-   \*count_of_tv_at_breaks (**added**): vector of number of
    time-varying parameters that change at each break.
-   *tv_spi* (**added**): vector of indices into vector *sp* of those
    time-varying parameters in the order of breaks as major and
    parameters as minor.
-   *tv_val* (**added**): vector of new values corresponding to
    *tv_spi*.

## v0.0.3 {#v0.0.3}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Archived&color=red)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.3)

This version was an early attempt to introduce parameters that can vary
at each simulation step. It was never implemented on the `C++`-side, and
has been superseded by [version 0.0.4](#v0.0.4)

### Assumptions (0.0.3)

### Mathematical Description (0.0.3)

In the non-time-varying case of [version 0.0.2](#v0.0.2), we have scalar
valued parameters. These parameters are constant in simulation time. We
now consider parameters that can vary at any particular simulation step.

Consider a focal scalar-valued time-varying parameter $u$. In the
non-time-varying case this scalar value, $u$, is an element of the
parameter vector, $\theta$.

$$
\theta = [..., u, ...]
$$

In the time-varying case, there is a series of values,
$u_0, u_1, ..., u_n$ associated with an initial value $u = u_0$ and the
values, $u_1, ..., u_n$, at $n_u$ break-points, $t_1, ..., t_{n_u}$. We
store these additional values by expanding the parameter vector to make
room for them.

$$
\theta = [..., u_0, u_1, ..., u_n, ...]
$$

Each simulation step is indexed $t = 1, ..., T$, where $T$ is the number
of simulation steps. If the time-varying parameter, $u$, is required at
time $t$ to update an element of the rate-matrix, the value of $u$ that
is used is $u_i$ such that $t \in [t_i, t_{i+1})$.

### User Interface (0.0.3)

We follow the `params_timevar` argument to `run_sim` in
`McMasterPandemic`, which allows the user to specify a data frame with
the following columns.

-   Date
-   Symbol
-   Value
-   Type

The definition of these columns at the time of writing is given
[here](https://github.com/mac-theobio/McMasterPandemic/blob/c1e8aa40d12918728e25a41368f751a8b7f4b983/R/sim_funs.R#L864).

The user must also specify the starting and ending calendar dates of the
simulation.

An example model with time variation can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(
    params, state,
    start_date = '2021-08-26', end_date = "2021-09-26",
    timevar_piece_wise = data.frame(
      Date = c("2021-09-01", "2021-09-15", "2021-09-10", "2021-08-28"),
      Symbol = c("mu", "beta0", "beta0", "mu"),
      Value = c(0.5, 0.1, 2, 0.2),
      Type = c("rel_prev", "rel_orig", "rel_prev", "rel_orig")
    ))
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_s))
  %>% add_parallel_accumulators(c("X", "N", "P", "V"))
  %>% add_tmb_indices()
)
```

### Data Structure (0.0.3)

Here we make a distinction between indices and time-indices. An index is
a 1-based integer identifying a value within a vector. A time-index is a
1-based integer identifying the simulation step.

-   `tvi_spi`: vector of indices for each time varying factor,
    identifying the elements of the `spi` vector from [version
    0.0.1](https://canmod.net/misc/flex_specs#v0.0.1)
-   `n_breaks`: vector of the number of time breaks for each time
    varying factor
-   `t_breaks`: vector of time-indices locating all time breaks for all
    time varying factors, organized such that time-indices associated
    with the same factor are grouped together and time-indices are all
    ascending

These indices and counts can be used to update the `spi` vector at each
simulation step. Here is an example in `R`.

```{r}
tvi_spi = c(1L, 3L, 6L, 10L, 14L, 19L)
n_breaks = c(3L, 3L, 2L, 2L, 2L, 2L)
t_breaks = c(
  2L, 6L, 17L, # factor 1 has 3 break-points 
  2L, 6L, 17L, # factor 2 has 3 break-points 
  15L, 20L,    # factor 3 has 2 break-points 
  15L, 20L,    # factor 4 has 2 break-points 
  15L, 20L,    # factor 5 has 2 break-points 
  15L, 20L     # factor 6 has 2 break-points 
)

# number of time varying factors
n = length(tvi_spi)

# initialize a break point counter. each element of t_breaks_t
# is associated with a time varying factor. each time a break
# point is encountered, increment the corresponding element in 
# this counter
t_breaks_t = rep(0, n)

# indices into the state param vector for all factors, including
# those that are not time varying
spi = c(30L, 27L, 30L, 27L, 3L, 15L, 33L, 18L, 4L, 15L, 33L, 19L, 5L,
  15L, 33L, 20L, 36L, 6L, 15L, 33L, 21L, 36L)
print(spi)
# loop over time steps
for(t in 1:30) {
  
  # loop over time-varying factors
  for(i in 1:n) {
    
    # only do something if factor i has a break-point at time t
    break_now = t == t_breaks[1 + t_breaks_t[i] + sum(n_breaks[1:(i-1)])]
    if(isTRUE(break_now)) {
      
      # increment the break-point counter
      t_breaks_t[i] = t_breaks_t[i] + 1
      
      # increment the spi vector for the ith time varying factor
      spi[tvi_spi[i]] = spi[tvi_spi[i]] + 1
      
    }
  }
  print(spi)
  
  # do the rest of what needs to be done in this simulation step
  # (e.g. update the rate matrix, update the state vector)
  # ...
}
```

Each row in this output is a time step and each column is the `spi`
index for a particular factor. Notice that only six columns change
through time, and these are associated with the six time-varying
factors. Columns 1 and 3 are associated with the same time-varying
parameter, and so they change at the same break-points. The same is true
of columns 6, 10, 14, and 19, which are associated with another
time-varying parameter.

```{r, eval=FALSE, echo=FALSE}
        Date Symbol Value     Type
1 2021-09-10  beta0   2.0 rel_prev
2 2021-09-15  beta0   0.1 rel_orig
3 2021-08-28     mu   0.2 rel_orig
4 2021-09-01     mu   0.5 rel_prev
```

```{r, eval=FALSE, echo=FALSE}
           S            E           Ia           Ip           Im           Is 
9.999950e+05 3.000000e+00 1.000000e+00 0.000000e+00 1.000000e+00 0.000000e+00 
           H           H2         ICUs         ICUd            D            R 
0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 
           X            V        beta0     beta0_t1     beta0_t2           Ca 
0.000000e+00 0.000000e+00 1.000000e+00 2.000000e+00 1.000000e-01 6.666667e-01 
          Cp           Cm           Cs        alpha        sigma      gamma_a 
1.000000e+00 1.000000e+00 1.000000e+00 3.333333e-01 1.923077e-01 1.428571e-01 
     gamma_m      gamma_s      gamma_p          rho        delta           mu 
1.428571e-01 1.748252e-01 2.000000e+00 1.000000e-01 0.000000e+00 9.560000e-01 
       mu_t1        mu_t2            N           E0 nonhosp_mort        iso_m 
1.912000e-01 9.560000e-02 1.000000e+06 5.000000e+00 0.000000e+00 0.000000e+00 
       iso_s         phi1         phi2         psi1         psi2         psi3 
0.000000e+00 7.600000e-01 5.000000e-01 5.000000e-02 1.250000e-01 2.000000e-01 
      c_prop c_delay_mean   c_delay_cv    proc_disp         zeta 
1.000000e-01 1.100000e+01 2.500000e-01 0.000000e+00 0.000000e+00
```

```{r, eval=FALSE, echo=FALSE}
$nbreaks

beta0    mu 
    2     2 

$tbreaks
[1] 15 20  2  6

$pi_tv_par
beta0    mu 
    1    14 
```

## v0.0.2 {#v0.0.2}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.2)

Iterated updates of the state vector.

### Assumptions (0.0.2)

1.  No parameter varies throughout a simulation
2.  Simple $dt = 1$ simulation (i.e. unit time step,
    `do_exponential == FALSE`, and `do_hazard == FALSE`)
3.  No stochasticity
4.  `MP_badsum_action = 'ignore'`
5.  No updates optimization
6.  No model structure (e.g. vaccination, age-structure, testing)
7.  [Assumptions 2-4 from 0.0.1](#assumptions-0.0.1)

### Mathematical Description (0.0.2)

Let $s$ be the state vector and $M$ be the rate matrix. Define the flows
matrix, $F$, to have the same dimensions as $M$. The elements of $F$ are
given by the following.

$$
F_{ij} = M_{ij} s_i
$$

Let $f_{\text{in}}$ and $f_{\text{out}}$ be the inflow and outflow
vectors, given by the column sums and row sums of $F$ respectively. If
the use specifies some states as being parallel accumulators, then the
columns associated with those special states are removed from $F$ before
the row sums are taken to compute $f_{\text{out}}$.

With these definitions in place the state vector update at each
iteration is given by the following.

$$
s \to s - f_{\text{out}} + f_{\text{in}}
$$ Here is a summary of the stages of a single simulation step under
this model.

1.  Update the rate matrix following [version 0.0.1](#v0.0.1)
2.  Compute the flow matrix
3.  Compute the inflow vector
4.  Compute the outflow vector, making sure to ignore the flow matrix
    columns associated with parallel accumulators
5.  Produce a new state by subtracting the outflows and adding the
    inflows
6.  Save every $k$th state vector to be returned

### User Interface (0.0.2)

In addition to the [interface elements specified in
0.0.1](#user-interface-0.0.1), the user needs to provide some additional
information. We need to provide a character vector of regex patterns
with which to find the indices of the parallel accumulators amongst the
state names (e.g. `r c("X", "N", "P", "V")`). For example, one way to
provide such a vector to an existing model would be the following.

```{r, eval=FALSE}
model = add_parallel_accumulators(model, c("X", "N", "P", "V"))
```

The user must also be able to specify the number of state vector updates
and the frequency (i.e. $k$ defined above in the Mathematical
Description) with which state vectors are saved.

### Data Structure (0.0.2)

The following pieces of information need to be added to those described
in [Data Structure (0.0.1)](#data-structure-0.0.1) in order to make
state vector updates.

-   Modified copies of the following integer vectors described in
    [0.0.1](#data-structure-0.0.1): `spi`, `modifier`, `from`, `to`,
    `count`

    -   These copies will only contain indices necessary for updating
        the rate matrix elements that could potentially change at each
        simulation step
    -   Currently this will include non-zero rate matrix elements that
        depend on at least one state variable (those that depend on
        parameters only will not need to be updated given that this
        version of the spec does not allow for time-varying parameters)

-   A vector, `par_accum_indices` of indices into the columns of the
    flows matrix, identifying the states that are parallel accumulators

-   The number of state vector updates to simulate

-   State saving frequency

## v0.0.1 {#v0.0.1}

[![Lifecycle
Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.1)

Update the non-zero elements of a rate matrix on the `TMB`/`C++` side
using a restricted set of operations (complements, inverses, sums, and
products). The update formula must be specified separately for each
non-zero element.

### Assumptions (0.0.1) {#assumptions-0.0.1}

1.  The state vector is not actually updated, making this a more-or-less
    useless spec (but it provides a good 'warm-up' and sanity check)
2.  A `param_pansim` and a `state_pansim` object exists or can be
    constructed
3.  If `make_state` is used to create the `state_pansim` object,
    `vaxify`, `ageify`, and `testify` are all set to `FALSE`
4.  There is no model structure (e.g. vaccination, age-structure,
    testing)

### Mathematical Description (0.0.1)

Any element, $x$, of either the parameter or state vector can be used to
define a *factor* in one of the following three forms.

-   Identity: $x$
-   Complement: $1-x$
-   Inverse: $1/x$

We collect these user-defined factors into a factor vector, $y$. Factors
can be repeated in $y$ if required. Any number of factors can be
multiplied together using `*` to produce a *product*. Any number of
factors and products can be added together using `+`.

There is a higher level nested structure associated with the factor
vector, $y$.

-   All factors associated with the, $i$th, non-zero rate matrix
    element, $M_{(i)}$, are grouped together in a contiguous block
-   Within the $i$th block, all factors associated with the $j$th
    product ($j = 1 ... n_i$) in that block are grouped together in a
    contiguous sub-block
-   Within the $i,j$th sub-block, all factors are given an index,
    $k = 1 ... m_{ij}$

With these definitions, the dependence of any non-zero rate matrix
element on the parameters and state variables is given by the following
expression.

$$
M_{(i)} = \sum_{j=1}^{n_i} \prod_{k=1}^{m_{ij}} y_{ijk}
$$

where $y_{ijk}$ is the $k$th factor associated with the $j$th product
associated with the $i$th non-zero rate matrix element.

### User Interface (0.0.1) {#user-interface-0.0.1}

Users can define the structure of a rate matrix with a list of
expressions, each determining the parameter-dependence and/or
state-dependence of a single non-zero rate matrix element. The standard
`McMasterPandemic` introductory example model can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(params, state)
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m))
  %>% add_tmb_indices()
)
```

The first step, `init_model`, in this pipeline initializes the
compartmental model by specifying objects containing the parameters and
state variables respectively.

Each subsequent call to `add_rate` defines the dependence of a single
non-zero rate matrix element on parameters and state variables. When
used in a pipeline, the `add_rate` function takes three arguments.

1.  `from` -- character string describing the state associated with the
    row of the rate matrix

2.  `to` -- character string describing the state associated with the
    column of the rate matrix

3.  `formula` -- one-sided model formula defining the dependence based
    on symbols associated named parameter and state vectors

    -   Any single parameter or state variable name, `x`, can be placed
        in parentheses to produce a *factor* in the following three ways

        -   Identity: `(x)`
        -   Complement: `(1-x)`
        -   Inverse: `(1/x)`

    -   Factors can be multiplied together with the `*` operator to
        produce a *product*

    -   Products and factors can be added together with the `+` operator
        to produce a non-zero rate matrix element

The final step of the pipeline adds the indices to be passed to
`TMB`/`C++` that are described in the [Data
Structure](#data-structure-0.0.1) section below.

### Data Structure (0.0.1) {#data-structure-0.0.1}

The object created by the pipeline in the [User
Interface](#user-interface-0.0.1) section above must contain at a
minimum the following seven objects.

1.  The initial value of a `state_pansim` object representing the
    vector, `state`, containing the state variables

2.  The initial value of a `param_pansim` object representing the
    vector, `params`, containing the parameters

3.  An integer vector, `spi`, of 1-based indices into a concatenation,
    `state_param`, of `state` and `param`

    -   The ordering of the elements of `state_param` is arbitrary
        because several integer vectors defined below contain indices
        into these elements for book-keeping purposes on the `TMB`/`C++`
        side
    -   However, typically it will make sense to at least keep the state
        variables together and the parameters together
    -   On the `R` side, `spi` has the property that `state_param[spi]`
        returns a vector of state variables and parameters in the order
        in which they occur in the factor vector defined above in the
        Mathematical Description section
    -   Note that `state_param[spi]` does not return the factor vector
        itself -- to get the factor vector from `state_param[spi]` you
        would need to modify some of the elements by taking their
        complements and inverses

4.  An integer vector, `modifier`, of the same length as `spi`

    -   Each element of `modifier` corresponds to a factor, as defined
        above in the Mathematical Description

    -   These elements bit-wise encode several pieces of information

        -   What elements of `state_param[spi]` need to transformed by
            complements or inverses
        -   Whether complements or inverses should be used for those
            elements that need to be transformed
        -   What elements of `state_param[spi]` need to be multiplied
            together to take products

    -   The binary expansion of these elements can each be represented
        with three bits, with each bit encoding different information

        -   The left-most bit is `1` if the corresponding factor is the
            first in a product that needs to be added to a previous
            product, and `0` otherwise
        -   The middle bit is `1` if the corresponding factor requires a
            complement and `0` otherwise
        -   The right-most bit is `1` if the corresponding factor
            requires an inverse and `0` otherwise

5.  An integer vector, `from`, of 1-based indices, the $i$th element of
    which points to the row of the $i$th non-zero rate matrix element

6.  An integer vector, `to`, of 1-based indices, the $i$th element of
    which points to the column of the $i$th non-zero rate matrix element

7.  An integer vector, `count`, the $i$th element of which gives the
    number of factors used to calculate the $i$th non-zero rate matrix
    element

    -   In terms of the Mathematical Description above, the elements of
        `count` store these sums $\sum_{j=1}^{n_i}m_{ij}$
