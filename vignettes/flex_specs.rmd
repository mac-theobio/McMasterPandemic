---
title: "Flexible Compartmental Modelling Specifications"
author: "Steve Walker, Weiguang Guan, Ben Bolker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flexible Compartmental Modelling Specifications}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

[![Live Version](https://img.shields.io/static/v1.svg?label=Live&message=Version&color=green)](https://canmod.net/misc/flex_specs)

[McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic) is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This refactoring will be done incrementally by implementing a series of versioned specifications that define each step. This document outlines these specifications, and provides a roadmap for planning future specifications.

We are using semantic versioning https://semver.org/ to provide versions for the specs. All versions of the spec that have not been implemented in a released version of the McMasterPandemic R package have major version 0 (e.g. 0.x.y, https://semver.org#spec-item-4) -- currently all of them.

There is a global option `MP_flex_spec_version` that is used by the `R` package to control what spec version is being assumed by the `TMB`/`C++` code. This helps in [testing](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/tests/testthat/test-tmb.R).

Spec versions have three life cycle stages: frozen, experimental, and archived. Each frozen version of the spec must contain the following five sections.

* _New Capabilities_ -- very short summary; refer to previous versions for background
* _Assumptions_ -- known assumptions that can help users/developers understand if this version will suite their needs
* _Mathematical Description_ -- precise definition of the new or changed features of the model; refer to previous versions for definitions being reused
* _User Interface_ -- short description and example of the user interface in `R` for model specification
* _Data Structure_ -- definition of the data structure to be passed from `R` to `TMB`/`C++` that stores the model structure

# Release Summary

## Frozen Versions

The specs for the following versions are released, which means that they will not change.

* [0.0.1 -- Simple rate matrix updates](#v0.0.1)

## Experimental Versions

The specs for the following versions are being actively developed and modified. These versions also serve as a roadmap. Note that version numbers of experimental versions can change without warning.

* [0.0.2 -- Simulation (iterated state variable updates)](#v0.0.2)
* [0.0.3 -- Time-varying parameters](#v0.0.3)
* [0.0.4 -- Model structure](#v0.0.4)
* [0.0.5 -- Condensation and calibration](#v0.0.5)
* [0.0.6 -- Hazard and ODE simulation](#v0.0.6)
* [0.0.7 -- Stochasticity](#v0.0.7)

## Archived Versions

The specs for the following versions are frozen but no longer respected by the `R` package. Archived versions cannot be ignored because Frozen and Experimental versions may still reference them. Currently no versions are archived.

# v0.0.7

## New Capabilities 0.0.7

Stochasticity.

# v0.0.6

## New Capabilities 0.0.6

Hazard and exponential simulation.

# v0.0.5

## New Capabilities 0.0.5

Condensation and calibration.

# v0.0.4

## New Capabilities (0.0.4)

Model structure (e.g. vaccination, age, testing) by modifying the user interface to accept matrix/vector inputs. There are two ways to do this: (1)  expand the inputs to fit into the scalar models below or (2) pass the inputs directly to `TMB`/`C++` and modify the code on that side.

# v0.0.3

## New Capabilities (0.0.3)

Time-varying parameters.  There is a question of whether we should start with break-points or just jump to general log-linear model.

# v0.0.2

## New Capabilities (0.0.2)

Iterated updates of the state vector.

## Assumptions (0.0.2)

1. No parameter varies throughout a simulation
2. Simple $dt = 1$ simulation (i.e. unit time step, `do_exponential == FALSE`, and `do_hazard == FALSE`)
4. No stochasticity
5. `MP_badsum_action = 'ignore'`
6. No updates optimization
7. No model structure (e.g. vaccination, age-structure, testing)
8. [Assumptions 2-4 from 0.0.1](#assumptions-0.0.1)

## Mathematical Description (0.0.2)

Let $s$ be the state vector and $M$ be the rate matrix. Define the flows matrix, $F$, to have the same dimensions as $M$. The elements of $F$ are given by the following.

$$
F_{ij} = M_{ij} s_i
$$

Let $f_{\text{in}}$ and $f_{\text{out}}$ be the inflow and outflow vectors, given by the column sums and row sums of $F$ respectively. If the use specifies some states as being parallel accumulators, then the columns associated with those special states are removed from $F$ before the row sums are taken to compute $f_{\text{out}}$.

With these definitions in place the state vector update at each iteration is given by the following.

$$
s \to s - f_{\text{out}} + f_{\text{in}}
$$
Here is a summary of the stages of a single simulation step under this model.

1. Update the rate matrix following [version 0.0.1](#v0.0.1)
2. Compute the flow matrix
3. Compute the inflow vector
4. Compute the outflow vector, making sure to ignore the flow matrix columns associated with parallel accumulators
5. Produce a new state by subtracting the outflows and adding the inflows

## User Interface (0.0.2)

In addition to the [interface elements specified in 0.0.1](#user-interface-0.0.1), the user needs to provide some additional information. We need to provide a character vector of regex patterns with which to find the indices of the parallel accumulators amongst the state names (e.g. `r c("X", "N", "P", "V")`). For example, one way to provide such a vector to an existing model would be the following.
```{r, eval=FALSE}
model = add_parallel_accumulators(model, c("X", "N", "P", "V"))
```

The user must also be able to specify the number of state vector updates.

## Data Structure (0.0.2)

The following pieces of information need to be added to those described in [Data Structure (0.0.2)](#data-structure-0.0.2) in order to make state vector updates.

* Modified copies of the following integer vectors described in [0.0.1](#data-structure-0.0.1): `spi`, `modifier`, `from`, `to`, `count`
   * These copies will only contain indices necessary for updating the rate matrix elements that could potentially change at each simulation step
   * Currently this will include non-zero rate matrix elements that depend on at least one state variable (those that depend on parameters only will not need to be updated given that this version of the spec does not allow for time-varying parameters)
* A vector, `par_accum_indices` of indices into the columns of the flows matrix, identifying the states that are parallel accumulators
* The number of state vector updates to simulate

# v0.0.1

## New Capabilities (0.0.1)

Update the non-zero elements of a rate matrix on the `TMB`/`C++` side using a restricted set of operations (complements, inverses, sums, and products). The update formula must be specified separately for each non-zero element.

## Assumptions (0.0.1)

1. The state vector is not actually updated, making this a more-or-less useless spec (but it provides a good 'warm-up' and sanity check)
2. A `param_pansim` and a `state_pansim` object exists or can be constructed
3. If `make_state` is used to create the `state_pansim` object, `vaxify`, `ageify`, and `testify` are all set to `FALSE`
4. There is no model structure (e.g. vaccination, age-structure, testing)

## Mathematical Description (0.0.1)

Any element, $x$, of either the parameter or state vector can be used to define a _factor_ in one of the following three forms.

* Identity: $x$
* Complement: $1-x$
* Inverse: $1/x$

We collect these user-defined factors into a factor vector, $y$. Factors can be repeated in $y$ if required. Any number of factors can be multiplied together using `*` to produce a _product_. Any number of factors and products can be added together using `+`.

There is a higher level nested structure associated with the factor vector, $y$.

* All factors associated with the, $i$th, non-zero rate matrix element, $M_{(i)}$, are grouped together in a contiguous block
* Within the $i$th block, all factors associated with the $j$th product ($j = 1 ... n_i$) in that block are grouped together in a contiguous sub-block
* Within the $i,j$th sub-block, all factors are given an index, $k = 1 ... m_{ij}$

With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression.

$$
M_{(i)} = \sum_{j=1}^{n_i} \prod_{k=1}^{m_{ij}} y_{ijk}
$$

where $y_{ijk}$ is the $k$th factor associated with the $j$th product associated with the $i$th non-zero rate matrix element.

## User Interface (0.0.1)

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter-dependence and/or state-dependence of a single non-zero rate matrix element. The standard `McMasterPandemic` introductory example model can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(params, state)
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m))
  %>% add_tmb_indices()
)
```

The first step, `init_model`, in this pipeline initializes the compartmental model by specifying `state_params` and `state_pansim` objects containing the parameters and state variables respectively.

Each subsequent call to `add_rate` defines the dependence of a single non-zero rate matrix element on parameters and state variables. When used in a pipeline, the `add_rate` function takes three arguments.

1. `from` -- character string describing the state associated with the row of the rate matrix
2. `to` -- character string describing the state associated with the column of the rate matrix
3. `formula` -- one-sided model formula defining the dependence based on symbols associated named parameter and state vectors
   * Any single parameter or state variable name, `x`, can be placed in parentheses to produce a _factor_ in the following three ways
      * Identity: `(x)`
      * Complement: `(1-x)`
      * Inverse: `(1/x)`
   * Factors can be multiplied together with the `*` operator to produce a _product_
   * Products and factors can be added together with the `+` operator to produce a non-zero rate matrix element

The final step of the pipeline adds the indices to be passed to `TMB`/`C++` that are described in the [Data Structure](#data-structure-0.0.1) section below.

## Data Structure (0.0.1)

The object created by the pipeline in the [User Interface](#user-interface-0.0.1) section above must contain at a minimum the following seven objects.

1. The initial value of a `state_pansim` object representing the vector, `state`, containing the state variables
2. The initial value of a `param_pansim` object representing the vector, `params`, containing the parameters
3. An integer vector, `spi`, of 1-based indices into a concatenation, `state_param`, of `state` and `param`
   * The ordering of the elements of `state_param` is arbitrary because several integer vectors defined below contain indices into these elements for book-keeping purposes on the `TMB`/`C++` side
   * However, typically it will make sense to at least keep the state variables together and the parameters together
   * On the `R` side, `spi` has the property that `state_param[spi]` returns a vector of state variables and parameters in the order in which they occur in the factor vector defined above in the Mathematical Description section
   * Note that `state_param[spi]` does not return the factor vector itself -- to get the factor vector from `state_param[spi]` you would need to modify some of the elements by taking their complements and inverses
4. An integer vector, `modifier`, of the same length as `spi`
   * Each element of `modifier` corresponds to a factor, as defined above in the Mathematical Description
   * These elements bit-wise encode several pieces of information
      * What elements of `state_param[spi]` need to transformed by complements or inverses
      * Whether complements or inverses should be used for those elements that need to be transformed
      * What elements of `state_param[spi]` need to be multiplied together to take products
   * The binary expansion of these elements can each be represented with three bits, with each bit encoding different information
      * The left-most bit is `1` if the corresponding factor is the first in a product that needs to be added to a previous product, and `0` otherwise
      * The middle bit is `1` if the corresponding factor requires a complement and `0` otherwise
      * The right-most bit is `1` if the corresponding factor requires an inverse and `0` otherwise
5. An integer vector, `from`, of 1-based indices, the $i$th element of which points to the row of the $i$th non-zero rate matrix element
6. An integer vector, `to`, of 1-based indices, the $i$th element of which points to the column of the $i$th non-zero rate matrix element
7. An integer vector, `count`, the $i$th element of which gives the number of factors used to calculate the $i$th non-zero rate matrix element
   * In terms of the Mathematical Description above, the elements of `count` store these sums $\sum_{j=1}^{n_i}m_{ij}$
