---
title: "Flexible Compartmental Modelling Specifications"
author: "Steve Walker, Weiguang Guan, Ben Bolker"
date: 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Flexible Compartmental Modelling Specifications}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

[![Live Version](https://img.shields.io/static/v1.svg?label=Updated&message=`r Sys.Date()`&color=blue)](https://canmod.net/misc/flex_specs)

[McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic) is a modelling tool that was rapidly developed to provide timely insights into the Covid-19 Pandemic in Canada. We are currently refactoring this tool so that it is faster and more general. This refactoring will be done incrementally by implementing a series of versioned specifications that define each step. This document outlines these specifications, and provides a roadmap for planning future specifications.

# Table of Contents

* [Versioning and Lifecycle](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)
* [Version Summary](https://canmod.net/misc/flex_specs#version-summary)
* [Version Descriptions](https://canmod.net/misc/flex_specs#version-descriptions)

# Versioning and Lifecycle

We are using semantic versioning https://semver.org/ to provide versions for the specs. All versions of a spec that have not been implemented in a released version of the McMasterPandemic R package have major version 0 (e.g. 0.x.y, https://semver.org#spec-item-4) -- currently all of them. Although none of these specs are released, they are being experimentally implemented on the [TMB branch of McMasterPandemic](https://github.com/mac-theobio/McMasterPandemic/tree/tmb), with R-side code [here](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/R/tmb.R). There is a global option, `MP_flex_spec_version`, that is used by this `R` code to control what spec version is being assumed by the `TMB`/`C++` code. This helps in [testing](https://github.com/mac-theobio/McMasterPandemic/blob/tmb/tests/testthat/test-tmb.R) as well. `C++` files that implement various spec versions are currently being placed [here](https://github.com/mac-theobio/McMasterPandemic/tree/tmb/inst/tmb).

Spec versions have three life cycle stages: frozen, experimental, and archived. If a frozen version needs clarification or updating, this clarification must be done by linking to a subsequent version that addresses the issue(s). Each frozen version of the spec must contain the following five sections.

* _New Capabilities_ -- very short summary; refer to previous versions for background
* _Assumptions_ -- known assumptions that can help users/developers understand if this version will suite their needs
* _Mathematical Description_ -- precise definition of the new or changed features of the model; refer to previous versions for definitions being reused
* _User Interface_ -- short description and example of the user interface in `R` for model specification
* _Data Structure_ -- definition of the data structure to be passed from `R` to `TMB`/`C++` that stores the model structure

# Version Summary

## Frozen Versions

The specs for the following versions are frozen, which means that they will not change.

* [0.0.1 -- Simple rate matrix updates](#v0.0.1)
* [0.0.2 -- Simulation (iterated state variable updates)](#v0.0.2)

## Experimental Versions

The specs for the following versions are being actively developed and modified. These versions also serve as a roadmap. Note that version numbers of experimental versions can change without warning.

* [0.0.3 -- Piece-wise constant exogenous time-variation of parameters (first attempt)](#v0.0.3)
* [0.0.4 -- Piece-wise constant exogenous time-variation of parameters](#v0.0.4)
* [0.0.5 -- Hazard simulation](#v0.0.5)
* [0.0.6 -- Log-linear exogenous time-variation of parameters](#v0.0.6)
* [0.1.0 -- Model structure](#v0.1.0)
* [0.2.0 -- Condensation and calibration](#v0.2.0)
* [0.2.1 -- ODE simulation](#v0.2.1)
* [0.2.2 -- Stochasticity](#v0.2.2)
* [0.3.0 -- Endogenous time-variation of parameters](#v0.3.0)
* [0.4.0 -- Time steps not equal to one](#0.4.0)

## Archived Versions

The specs for archived versions are frozen but no longer respected by the `McMasterPandemic` `R` package and/or its test framework. Archived versions cannot be ignored because Frozen and Experimental versions may still reference them.


# Version Descriptions

## v0.4.0

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.4.0)

Time steps not equal to one.

## v0.3.0

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.3.0)

Endogenous time-variation of parameters.

## v0.2.2

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.2)

Stochasticity.

## v0.2.1

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.1)

ODE (i.e. exponential) simulation.

## v0.2.0

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.2.0)

Condensation and calibration.

## v0.1.0

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.1.0)

Model structure (e.g. vaccination, age, testing) by modifying the user interface to accept matrix/vector inputs. There are two ways to do this: (1)  expand the inputs to fit into the scalar models below or (2) pass the inputs directly to `TMB`/`C++` and modify the code on that side.

### User Interface (0.1.0)

Introduce a new `struc` object class that allows for symbolic manipulation of matrices and vectors of parameters and state variables. As an example, the force of infection under the two-dose vaccination model can be given by the following.
```{r, echo=FALSE}
wrap_paren = function(x) {
  paste0('(', x, ')')
}
```

Start by getting a set of vaccination parameters and state variables.
```{r}
library(McMasterPandemic)
library(dplyr)
options(macpan_pfun_method = "grep")

base_params <- read_params("PHAC.csv")
vax_params <- expand_params_vax(
  params = base_params,
  model_type = "twodose"
)
base_state <- make_state(params = base_params)
vax_state <- expand_state_vax(
  x = base_state,
  model_type = "twodose",
  unif = FALSE
)
M = make_ratemat(vax_state, vax_params)
#pfun("S", "E", M)
```

Create a symbolic vector of I-state variables, with 4 base states by 5 vaccination categories = 20 variables.
```{r}
Istate = (McMasterPandemic:::expand_names(
  c('Ia', 'Ip', 'Im', 'Is'),   # = Icats
  attr(vax_params, 'vax_cat')) # = vax_cats
  %>% wrap_paren
  %>% struc
)
as.matrix(Istate)
```

Create a vector of base transmission rates associated with each of the 4 base I-states.
```{r}
baseline_trans_rates =
  struc(
  '(Ca)',
  '(Cp)',
  '(1 - iso_m) * (Cm)',
  '(1 - iso_s) * (Cs)') *
  struc('(beta0) * (1/N)')
as.matrix(baseline_trans_rates)
```

Create a 5-by-5 block matrix of vaccine efficacies
```{r}
vax_trans_red = struc_block(struc(
  '(1)',
  '(1)',
  '(1 - vax_efficacy_dose1)',
  '(1 - vax_efficacy_dose1)',
  '(1 - vax_efficacy_dose2)'),
  row_times = 1, col_times = 5)
as.matrix(vax_trans_red)
```

And finally the force of infection vector, which looks like we really need to introduce the capability for common factors.
```{r}
foi = kronecker(vax_trans_red, t(baseline_trans_rates)) %*% Istate
foi
```

## v0.0.6

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.6)

Log-linear exogenous time-variation of parameters.

### Mathematical Description (0.0.6)

Such parameters have their own parameters that determine a model of time-variation. These latter parameters get transformed to produce a time series of parameter values of length equal to the number of time steps. One simple thing to do would be to put these time series into the parameter vector, and when parameters are accessed use the index `spi + t` where `spi` is the index into the `state_param` vector that picks out the first parameter in the time series and `t` is the current time step. I'm a little worried that this could have us jumping around to different memory locations too much, so I will need to discuss with Weiguang and Ben.


$$
\log(u) = \log(u_0) + Xv
$$
where $u$ is a vector of length $T$, the number of time steps, $u_0$ is a scalar parameter, $v$ is a vector of length $D < T$ that parameterizes the model of time variation, and $X$ is a $T$-by-$D$ matrix of constant columns (e.g. indicator variables, spline bases). Note that logs of vectors are taken element-wise.

$$
\log(u_t) = \log(u_0) + \sum_{i=1}^Dx_{ti}v_i
$$
$$
u_t = u_0 \prod_{i=1}^D\exp\left(x_{ti}v_i\right)
$$
For example:

* $D=2$ breakpoints 
* $v_1 = v_2 = \log\left(\frac{1}{2}\right) \approx -0.69$
* $x_{ti} = \begin{cases} 1, & t \ge t_i \\ 0, & \text{otherwise} \end{cases}$

In this case we have the following time variation of $u$.
$$
u_t = 
\begin{cases} 
u_0, & t < t_1 \\
\frac{u_0}{2}, & t_1 \le t < t_2 \\
\frac{u_0}{4}, & t \ge t_2
\end{cases}
$$

## v0.0.5

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Experimental&color=yellow)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.5)

Hazard simulation.

### Mathematical Description

Define the sums of the rows of the rate matrix. 
$$
r_i = \sum_{j=1}^n M_{ij}
$$
Define the elements of a vector of exponentiated row sums
$$
\rho_i = \exp(-r_i)
$$

Define the elements of a normalized state vector.
$$
\tilde{s}_i = \begin{cases}
0 & r_i = 0 \\
\frac{s_i}{r_i} & \text{otherwise}
\end{cases}
$$
With these definitions we can define the modified flow matrix.
$$
F_{ij} = \begin{cases}
M_{ij}\tilde{s}_i(1-\rho_i) & i \ne j \\
0 & \text{otherwise}
\end{cases}
$$
This modified flow matrix can now be used in the same way as the unmodified flow matrix to produce state variable updates following spec version 0.0.2.

### User Interface (0.0.5)

A Boolean argument needs to be added to the interface, indicating whether or not the hazard-based flow matrix is used rather than the simple flow matrix.

### Data Structure (0.0.5)

The data structure is equivalent to 0.0.4.

## v0.0.4

 We begin with simple piece-wise constant time-variation. _Piece-wise constant_ means that each time-varying parameter is associated with a sequence of break-points at which the value of the parameter changes -- at all other times the parameter is constant. We plan to relax the _piece-wise constant_ restriction in [version 0.0.6](#v0.0.6).

### New Capabilities (0.0.4)

Patch of the spec from 0.0.3 on piece-wise constant time-varying parameters.

### Data Structure (0.0.4)

 - *update_indices* (**removed**): a second set of *from* *to*, etc for 
 need-to-update elements proposed in spec 0.0.2 is removed in this proposal because the 
 newly introduced *upateidx* provides the information needed.
 - *upateidx* (**added**): a vector of indices into vectors *from*, *to*, and *count* of those elements 
 in the rate matrix that need to be updated. It includes the indices of the elements that 
 depend on either the state vector (0.0.2), or time-varying parameters (0.0.3 or 0.0.4), 
 or both. At each simulation step, we will update only those elements specified by 
 *updateidx*. The drawback of this design is that elements that only depends on piece-wise 
 parameters (0.0.3) are updated at each step although they only need to be updated at 
 certain breaks.
 - *breaks* (**added**): 
 vector of all the breaks.
 - *count_of_tv_at_breaks (**added**): vector of number of 
 time-varying parameters that change at each break.
 - *tv_spi* (**added**): vector of 
 indices into vector *sp* of those time-varying parameters in the order of breaks as major 
 and parameters as minor.
 - *tv_val* (**added**): vector of new values corresponding to 
 *tv_spi*.

## v0.0.3

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Archived&color=red)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.3)

This version was an early attempt to introduce parameters that can vary at each simulation step. It was never implemented on the `C++`-side, and has been superseded by [version 0.0.4](#v0.0.4)

### Assumptions (0.0.3)

### Mathematical Description (0.0.3)

In the non-time-varying case of [version 0.0.2](#v0.0.2), we have scalar valued parameters. These parameters are constant in simulation time. We now consider parameters that can vary at any particular simulation step.

Consider a focal scalar-valued time-varying parameter $u$. In the non-time-varying case this scalar value, $u$, is an element of the parameter vector, $\theta$.

$$
\theta = [..., u, ...]
$$

In the time-varying case, there is a series of values, $u_0, u_1, ..., u_n$ associated with an initial value $u = u_0$ and the values, $u_1, ..., u_n$, at $n_u$ break-points, $t_1, ..., t_{n_u}$. We store these additional values by expanding the parameter vector to make room for them.

$$
\theta = [..., u_0, u_1, ..., u_n, ...]
$$

Each simulation step is indexed $t = 1, ..., T$, where $T$ is the number of simulation steps. If the time-varying parameter, $u$, is required at time $t$ to update an element of the rate-matrix, the value of $u$ that is used is $u_i$ such that $t \in [t_i, t_{i+1})$.

### User Interface (0.0.3)

We follow the `params_timevar` argument to `run_sim` in `McMasterPandemic`, which allows the user to specify a data frame with the following columns.

* Date
* Symbol
* Value
* Type

The definition of these columns at the time of writing is given [here](https://github.com/mac-theobio/McMasterPandemic/blob/c1e8aa40d12918728e25a41368f751a8b7f4b983/R/sim_funs.R#L864).

The user must also specify the starting and ending calendar dates of the simulation.

An example model with time variation can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(
    params, state,
    start_date = '2021-08-26', end_date = "2021-09-26",
    timevar_piece_wise = data.frame(
      Date = c("2021-09-01", "2021-09-15", "2021-09-10", "2021-08-28"),
      Symbol = c("mu", "beta0", "beta0", "mu"),
      Value = c(0.5, 0.1, 2, 0.2),
      Type = c("rel_prev", "rel_orig", "rel_prev", "rel_orig")
    ))
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_s))
  %>% add_parallel_accumulators(c("X", "N", "P", "V"))
  %>% add_tmb_indices()
)
```

### Data Structure (0.0.3)

Here we make a distinction between indices and time-indices. An index is a 1-based integer identifying a value within a vector. A time-index is a 1-based integer identifying the simulation step.

* `tvi_spi`: vector of indices for each time varying factor, identifying the elements of the `spi` vector from [version 0.0.1](https://canmod.net/misc/flex_specs#v0.0.1)
* `n_breaks`: vector of the number of time breaks for each time varying factor
* `t_breaks`: vector of time-indices locating all time breaks for all time varying factors, organized such that time-indices associated with the same factor are grouped together and time-indices are all ascending

These indices and counts can be used to update the `spi` vector at each simulation step. Here is an example in `R`.

```{r}
tvi_spi = c(1L, 3L, 6L, 10L, 14L, 19L)
n_breaks = c(3L, 3L, 2L, 2L, 2L, 2L)
t_breaks = c(
  2L, 6L, 17L, # factor 1 has 3 break-points 
  2L, 6L, 17L, # factor 2 has 3 break-points 
  15L, 20L,    # factor 3 has 2 break-points 
  15L, 20L,    # factor 4 has 2 break-points 
  15L, 20L,    # factor 5 has 2 break-points 
  15L, 20L     # factor 6 has 2 break-points 
)

# number of time varying factors
n = length(tvi_spi)

# initialize a break point counter. each element of t_breaks_t
# is associated with a time varying factor. each time a break
# point is encountered, increment the corresponding element in 
# this counter
t_breaks_t = rep(0, n)

# indices into the state param vector for all factors, including
# those that are not time varying
spi = c(30L, 27L, 30L, 27L, 3L, 15L, 33L, 18L, 4L, 15L, 33L, 19L, 5L,
  15L, 33L, 20L, 36L, 6L, 15L, 33L, 21L, 36L)
print(spi)
# loop over time steps
for(t in 1:30) {
  
  # loop over time-varying factors
  for(i in 1:n) {
    
    # only do something if factor i has a break-point at time t
    break_now = t == t_breaks[1 + t_breaks_t[i] + sum(n_breaks[1:(i-1)])]
    if(isTRUE(break_now)) {
      
      # increment the break-point counter
      t_breaks_t[i] = t_breaks_t[i] + 1
      
      # increment the spi vector for the ith time varying factor
      spi[tvi_spi[i]] = spi[tvi_spi[i]] + 1
      
    }
  }
  print(spi)
  
  # do the rest of what needs to be done in this simulation step
  # (e.g. update the rate matrix, update the state vector)
  # ...
}
```

Each row in this output is a time step and each column is the `spi` index for a particular factor.  Notice that only six columns change through time, and these are associated with the six time-varying factors.  Columns 1 and 3 are associated with the same time-varying parameter, and so they change at the same break-points.  The same is true of columns 6, 10, 14, and 19, which are associated with another time-varying parameter.

```{r, eval=FALSE, echo=FALSE}
        Date Symbol Value     Type
1 2021-09-10  beta0   2.0 rel_prev
2 2021-09-15  beta0   0.1 rel_orig
3 2021-08-28     mu   0.2 rel_orig
4 2021-09-01     mu   0.5 rel_prev
```

```{r, eval=FALSE, echo=FALSE}
           S            E           Ia           Ip           Im           Is 
9.999950e+05 3.000000e+00 1.000000e+00 0.000000e+00 1.000000e+00 0.000000e+00 
           H           H2         ICUs         ICUd            D            R 
0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 
           X            V        beta0     beta0_t1     beta0_t2           Ca 
0.000000e+00 0.000000e+00 1.000000e+00 2.000000e+00 1.000000e-01 6.666667e-01 
          Cp           Cm           Cs        alpha        sigma      gamma_a 
1.000000e+00 1.000000e+00 1.000000e+00 3.333333e-01 1.923077e-01 1.428571e-01 
     gamma_m      gamma_s      gamma_p          rho        delta           mu 
1.428571e-01 1.748252e-01 2.000000e+00 1.000000e-01 0.000000e+00 9.560000e-01 
       mu_t1        mu_t2            N           E0 nonhosp_mort        iso_m 
1.912000e-01 9.560000e-02 1.000000e+06 5.000000e+00 0.000000e+00 0.000000e+00 
       iso_s         phi1         phi2         psi1         psi2         psi3 
0.000000e+00 7.600000e-01 5.000000e-01 5.000000e-02 1.250000e-01 2.000000e-01 
      c_prop c_delay_mean   c_delay_cv    proc_disp         zeta 
1.000000e-01 1.100000e+01 2.500000e-01 0.000000e+00 0.000000e+00
```

```{r, eval=FALSE, echo=FALSE}
$nbreaks

beta0    mu 
    2     2 

$tbreaks
[1] 15 20  2  6

$pi_tv_par
beta0    mu 
    1    14 
```

## v0.0.2

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.2)

Iterated updates of the state vector.

### Assumptions (0.0.2)

1. No parameter varies throughout a simulation
2. Simple $dt = 1$ simulation (i.e. unit time step, `do_exponential == FALSE`, and `do_hazard == FALSE`)
4. No stochasticity
5. `MP_badsum_action = 'ignore'`
6. No updates optimization
7. No model structure (e.g. vaccination, age-structure, testing)
8. [Assumptions 2-4 from 0.0.1](#assumptions-0.0.1)

### Mathematical Description (0.0.2)

Let $s$ be the state vector and $M$ be the rate matrix. Define the flows matrix, $F$, to have the same dimensions as $M$. The elements of $F$ are given by the following.

$$
F_{ij} = M_{ij} s_i
$$

Let $f_{\text{in}}$ and $f_{\text{out}}$ be the inflow and outflow vectors, given by the column sums and row sums of $F$ respectively. If the use specifies some states as being parallel accumulators, then the columns associated with those special states are removed from $F$ before the row sums are taken to compute $f_{\text{out}}$.

With these definitions in place the state vector update at each iteration is given by the following.

$$
s \to s - f_{\text{out}} + f_{\text{in}}
$$
Here is a summary of the stages of a single simulation step under this model.

1. Update the rate matrix following [version 0.0.1](#v0.0.1)
2. Compute the flow matrix
3. Compute the inflow vector
4. Compute the outflow vector, making sure to ignore the flow matrix columns associated with parallel accumulators
5. Produce a new state by subtracting the outflows and adding the inflows
6. Save every $k$th state vector to be returned

### User Interface (0.0.2)

In addition to the [interface elements specified in 0.0.1](#user-interface-0.0.1), the user needs to provide some additional information. We need to provide a character vector of regex patterns with which to find the indices of the parallel accumulators amongst the state names (e.g. `r c("X", "N", "P", "V")`). For example, one way to provide such a vector to an existing model would be the following.
```{r, eval=FALSE}
model = add_parallel_accumulators(model, c("X", "N", "P", "V"))
```

The user must also be able to specify the number of state vector updates and the frequency (i.e. $k$ defined above in the Mathematical Description) with which state vectors are saved.

### Data Structure (0.0.2)

The following pieces of information need to be added to those described in [Data Structure (0.0.1)](#data-structure-0.0.1) in order to make state vector updates.

* Modified copies of the following integer vectors described in [0.0.1](#data-structure-0.0.1): `spi`, `modifier`, `from`, `to`, `count`
   * These copies will only contain indices necessary for updating the rate matrix elements that could potentially change at each simulation step
   * Currently this will include non-zero rate matrix elements that depend on at least one state variable (those that depend on parameters only will not need to be updated given that this version of the spec does not allow for time-varying parameters)
* A vector, `par_accum_indices` of indices into the columns of the flows matrix, identifying the states that are parallel accumulators
* The number of state vector updates to simulate
* State saving frequency

## v0.0.1

[![Lifecycle Badge](https://img.shields.io/static/v1.svg?label=Lifecycle&message=Frozen&color=green)](https://canmod.net/misc/flex_specs#versioning-and-lifecycle)

### New Capabilities (0.0.1)

Update the non-zero elements of a rate matrix on the `TMB`/`C++` side using a restricted set of operations (complements, inverses, sums, and products). The update formula must be specified separately for each non-zero element.

### Assumptions (0.0.1)

1. The state vector is not actually updated, making this a more-or-less useless spec (but it provides a good 'warm-up' and sanity check)
2. A `param_pansim` and a `state_pansim` object exists or can be constructed
3. If `make_state` is used to create the `state_pansim` object, `vaxify`, `ageify`, and `testify` are all set to `FALSE`
4. There is no model structure (e.g. vaccination, age-structure, testing)

### Mathematical Description (0.0.1)

Any element, $x$, of either the parameter or state vector can be used to define a _factor_ in one of the following three forms.

* Identity: $x$
* Complement: $1-x$
* Inverse: $1/x$

We collect these user-defined factors into a factor vector, $y$. Factors can be repeated in $y$ if required. Any number of factors can be multiplied together using `*` to produce a _product_. Any number of factors and products can be added together using `+`.

There is a higher level nested structure associated with the factor vector, $y$.

* All factors associated with the, $i$th, non-zero rate matrix element, $M_{(i)}$, are grouped together in a contiguous block
* Within the $i$th block, all factors associated with the $j$th product ($j = 1 ... n_i$) in that block are grouped together in a contiguous sub-block
* Within the $i,j$th sub-block, all factors are given an index, $k = 1 ... m_{ij}$

With these definitions, the dependence of any non-zero rate matrix element on the parameters and state variables is given by the following expression.

$$
M_{(i)} = \sum_{j=1}^{n_i} \prod_{k=1}^{m_{ij}} y_{ijk}
$$

where $y_{ijk}$ is the $k$th factor associated with the $j$th product associated with the $i$th non-zero rate matrix element.

### User Interface (0.0.1)

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter-dependence and/or state-dependence of a single non-zero rate matrix element. The standard `McMasterPandemic` introductory example model can be defined as follows.

```{r, eval=FALSE}
params = read_params('ICU1.csv')
state = make_state(params = params)
model = (
  init_model(params, state)
  %>% add_rate("E", "Ia", ~ (alpha) * (sigma))
  %>% add_rate("E", "Ip", ~ (1 - alpha) * (sigma))
  %>% add_rate("Ia", "R", ~ (gamma_a))
  %>% add_rate("Ip", "Im", ~ (mu) * (gamma_p))
  %>% add_rate("Ip", "Is", ~ (1 - mu) * (gamma_p))
  %>% add_rate("Im", "R", ~ (gamma_m))
  %>% add_rate("Is", "H", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("Is", "ICUs", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s))
  %>% add_rate("Is", "ICUd", ~ 
                 (1 - nonhosp_mort) * (1 - phi1) * (phi2) * (gamma_s))
  %>% add_rate("Is", "D", ~ (nonhosp_mort) * (gamma_s))
  %>% add_rate("ICUs", "H2", ~ (psi1))
  %>% add_rate("ICUd", "D", ~ (psi2))
  %>% add_rate("H2", "R", ~ (psi3))
  %>% add_rate("H", "R", ~ (rho))
  %>% add_rate("Is", "X", ~ (1 - nonhosp_mort) * (phi1) * (gamma_s))
  %>% add_rate("S",  "E", ~
                 (Ia) * (beta0) * (1/N) * (Ca) +
                 (Ip) * (beta0) * (1/N) * (Cp) +
                 (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) +
                 (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m))
  %>% add_tmb_indices()
)
```

The first step, `init_model`, in this pipeline initializes the compartmental model by specifying objects containing the parameters and state variables respectively.

Each subsequent call to `add_rate` defines the dependence of a single non-zero rate matrix element on parameters and state variables. When used in a pipeline, the `add_rate` function takes three arguments.

1. `from` -- character string describing the state associated with the row of the rate matrix
2. `to` -- character string describing the state associated with the column of the rate matrix
3. `formula` -- one-sided model formula defining the dependence based on symbols associated named parameter and state vectors
   * Any single parameter or state variable name, `x`, can be placed in parentheses to produce a _factor_ in the following three ways
      * Identity: `(x)`
      * Complement: `(1-x)`
      * Inverse: `(1/x)`
   * Factors can be multiplied together with the `*` operator to produce a _product_
   * Products and factors can be added together with the `+` operator to produce a non-zero rate matrix element

The final step of the pipeline adds the indices to be passed to `TMB`/`C++` that are described in the [Data Structure](#data-structure-0.0.1) section below.

### Data Structure (0.0.1)

The object created by the pipeline in the [User Interface](#user-interface-0.0.1) section above must contain at a minimum the following seven objects.

1. The initial value of a `state_pansim` object representing the vector, `state`, containing the state variables
2. The initial value of a `param_pansim` object representing the vector, `params`, containing the parameters
3. An integer vector, `spi`, of 1-based indices into a concatenation, `state_param`, of `state` and `param`
   * The ordering of the elements of `state_param` is arbitrary because several integer vectors defined below contain indices into these elements for book-keeping purposes on the `TMB`/`C++` side
   * However, typically it will make sense to at least keep the state variables together and the parameters together
   * On the `R` side, `spi` has the property that `state_param[spi]` returns a vector of state variables and parameters in the order in which they occur in the factor vector defined above in the Mathematical Description section
   * Note that `state_param[spi]` does not return the factor vector itself -- to get the factor vector from `state_param[spi]` you would need to modify some of the elements by taking their complements and inverses
4. An integer vector, `modifier`, of the same length as `spi`
   * Each element of `modifier` corresponds to a factor, as defined above in the Mathematical Description
   * These elements bit-wise encode several pieces of information
      * What elements of `state_param[spi]` need to transformed by complements or inverses
      * Whether complements or inverses should be used for those elements that need to be transformed
      * What elements of `state_param[spi]` need to be multiplied together to take products
   * The binary expansion of these elements can each be represented with three bits, with each bit encoding different information
      * The left-most bit is `1` if the corresponding factor is the first in a product that needs to be added to a previous product, and `0` otherwise
      * The middle bit is `1` if the corresponding factor requires a complement and `0` otherwise
      * The right-most bit is `1` if the corresponding factor requires an inverse and `0` otherwise
5. An integer vector, `from`, of 1-based indices, the $i$th element of which points to the row of the $i$th non-zero rate matrix element
6. An integer vector, `to`, of 1-based indices, the $i$th element of which points to the column of the $i$th non-zero rate matrix element
7. An integer vector, `count`, the $i$th element of which gives the number of factors used to calculate the $i$th non-zero rate matrix element
   * In terms of the Mathematical Description above, the elements of `count` store these sums $\sum_{j=1}^{n_i}m_{ij}$
