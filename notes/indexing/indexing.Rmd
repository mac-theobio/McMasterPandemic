---
title: "Indices"
output: md_document
---

# Create Indices for Accessing Elements of the Rate Matrix

## Dependence of the Rate Matrix on the Parameter Vector

### Warm Up Model

Let $M = [M_{i,j}]$ be the rate matrix and $\theta = [\theta_k]$ be the parameter vector. The elements of $M$ are functions of the elements of $\theta$. The dependence of $M$ on $\theta$ can only take certain forms. In particular, each element of $M$ is a product of zero or more elements of $\theta$ or their complements (i.e. $1-\theta$). Here are some examples:

* $M_{4,5} = \theta_1 \theta_2$
* $M_{1,2} = (1-\theta_3)\theta_4\theta_5(1-\theta_{10})$
* $M_{10,3} = (1-\theta_4)$

In general,

$M_{i,j} = \prod_k \theta_k^{x_{ijk}} (1-\theta_k)^{y_{ijk}}$

where $x_{ijk}$ (or $y_{ijk}$) is one if $M_{i,j}$ depends on $\theta_k$ (or $1 - \theta_k$) and zero otherwise. Note that these $x$ and $y$ numbers define the dependence of $M$ on $\theta$, and are constants that do not change throughout a simulation.

### Rate Matrix Model

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter and state dependence of a non-zero rate matrix element. For example,
```{r, eval=FALSE}
list(
  # recovery
  list(from = "Ia", to = "R",    
       formula = ~ (gamma_a)),
  # hospitalizations
  list(from = "Is", to = "ICUs", 
       formula = ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s)),
  # force of infection
  list(from = "S",  to = "E",
       formula = ~ 
         (Ia) * (beta0) * (1/N) * (Ca) + 
         (Ip) * (beta0) * (1/N) * (Cp) + 
         (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) + 
         (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m)),
  list('etc...')
)
```
The formulas allow the following operations:
* Any element, $x$, of either the parameter or state vector can be placed in parentheses to produce a _factor_ in one of the following three forms
  * Identity: `(x)`
  * Complement: `(1-x)`
  * Inverse: `(1/x)`
* Any number of factors in parentheses can be multiplied together using `*` to produce a _product_
* Any number of factors and products can be summed together using `+`

We make a series of transformations from the state vector, $s$, and parameter vector to the rate matrix, $M$. Given how TMB works, we need to distinguish parameters that will be optimized, $\theta$, from those that will remain constant, $\eta$ (or those that are derived from parameters being optimized, e.g. time-varying??, still unsure how time varying machinery is working with run_sim_break or will work with run_sim_loglin). We define two intermediate vectors as well: the factor vector, $v$, and the product vector, $u$. At a high level we take the elements of the state vector and two parameter vectors into the non-zero elements of the rate matrix as follows.
$$
\{s,\eta,\theta\} \rightarrow v \rightarrow u \rightarrow M
$$

The factor vector, $v$, is a function of $s$ and $\theta$.  The dependence is simple in that each scalar element of the factor vector can be one of the following.

* [identity] an element, $x$, of either $s$ or $\theta$
* [complement] the complement of this element, $1-x$
* [inverse] the inverse of this element, $1/x$

In the future we can generalize this by adding more operations, but for now identity, complement, and inverse should be sufficient to do everything -- although it will make age structure awkward given that such problems are more naturally handled with matrix operations like Kronecker products and sweeps.

The product vector, $u$, is a function of $v$.  The dependence is simple in that each element of the product vector is the product of one or more elements of the factor vector, $v$.

The non-zero elements of the rate matrix, $M$, can be any one of the following.

* An element of the factor vector, $v$
* An element of the product vector, $u$
* The sum of one of more elements in the product vector, $u$

The CIPS model allows one to compute simple rate matrix structure where the elements of the rate matrix are simply parameters.  An example in MacPan is the following.
```{r, eval=FALSE}
afun("Ia", "R", gamma_a)
```
CIPS also allows the common products of parameters and complements of parameters, such as this example from MacPan.
```{r, eval=FALSE}
afun("Is", "ICUs", (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * gamma_s)
```
CIPS also allows one to formulate the force of infection.
```{r, eval=FALSE}
afun("S", "E", sum(state[c("Ia", "Ip", "Im", "Is")] 
  * beta0 
  * c(Ca, Cp, (1 - iso_m) * Cm, (1 - iso_s) * Cs) 
  / N))
```
Explicitly expressing the force of infection in CIPS we have.
$$
s = [Ia, Ip, Im, Is]
$$
$$
\theta = [beta0, Ca, Cp, Cm, Cs, iso_m, iso_s, N]
$$
$$
u = [s_1, s_2, s_3, s_4, \theta_1, \theta_2, \theta_3, \theta_4, \theta_5, 1 - \theta_6, 1 - \theta_7, 1/\theta_8]
$$
$$
v = [u_1  u_5  u_6          u_{12}, 
     u_2  u_5  u_7          u_{12},
     u_3  u_5  u_{10}  u_8  u_{12},
     u_4  u_5  u_{11}  u_9  u_{12}]
$$
And finally the non-zero element of $M$ determining the rate of flow from S to E is simply the sum of the elements in the products vector, $v$. Typically this summation will be taken over a subset of the elements of the products vector, but we simplified this example to include on elements that are involved in the force of infection computation.


Such a list could be parsed into a data structure that can be consumed by TMB/C++.
```{r}
list(
  rate_matrix = list(
    from = 1, to = 2, operation = ''
  ),
  factors = data.frame(
    
  )
)
```

The CIPS model allows a separation of concerns among epidemiological modellers and C++ developers.

## User Interface

When coding this up, we do not need to explicitly store all of the zeros in $x$ and $y$. Instead we just track what elements of $M$ depend on what elements of $\theta$ and whether/how the dependence involves complements of the values of $\theta$.

Before defining the interface, assume that we have a rate matrix on the R-side with named rows and columns, and a named parameter vector also on the R-side with named elements.
```{r}
theta <- McMasterPandemic:::read_params("ICU1.csv")
state = McMasterPandemic:::make_state(params=theta)
M <- McMasterPandemic:::make_ratemat(params=theta, state=state, sparse=TRUE)
print(theta)
print(M)
```

```{r}
state_names = row.names(M)
par_names = names(theta)
print(state_names)
print(par_names)
```


```{r}
pfun <- McMasterPandemic:::pfun
```


```{r}
make_beta_light <- function(state, params, full = TRUE) {
    # does not use 'full' (argument)
    # does not use 'testcats' (below)
    Icats <- c("Ia", "Ip", "Im", "Is")
    testcats <- c("_u", "_p", "_n", "_t")
    Icat_prop_vec <- with(
        as.list(params),
        c(Ca, Cp, (1 - iso_m) * Cm, (1 - iso_s) * Cs)
    )
    names(Icat_prop_vec) <- Icats
    beta_0 <- with(as.list(params), beta0 * Icat_prop_vec / N)
    beta <- setNames(numeric(length(state)), names(state))
    beta[names(beta_0)] <- beta_0
    return(beta)
}

update_ratemat_light <- function(ratemat, state, params, testwt_scale = "N") {
  # testwt_scale not needed
  ratemat[pfun("S", "E", ratemat)] <- update_foi(state, params, make_beta(state, params))
}

update_foi_light <- function(state, params, beta) {
  # params not needed
  foi <- sum(state * beta)
}

```



