---
title: "Indices"
output: html_document
---

# Create Indices for Accessing Elements of the Rate Matrix

## Rate Matrix Models

### Warm Up Rate Matrix Model

Allow each element of the rate matrix to depend on products of parameters (or their complements).

Let $M = [M_{i,j}]$ be the rate matrix and $\theta = [\theta_k]$ be the parameter vector. The elements of $M$ are functions of the elements of $\theta$. The dependence of $M$ on $\theta$ can only take certain forms. In particular, each element of $M$ is a product of zero or more elements of $\theta$ or their complements (i.e. $1-\theta$). Here are some examples:

* $M_{4,5} = \theta_1 \theta_2$
* $M_{1,2} = (1-\theta_3)\theta_4\theta_5(1-\theta_{10})$
* $M_{10,3} = (1-\theta_4)$

In general,

$M_{i,j} = \prod_k \theta_k^{x_{ijk}} (1-\theta_k)^{y_{ijk}}$

where $x_{ijk}$ (or $y_{ijk}$) is one if $M_{i,j}$ depends on $\theta_k$ (or $1 - \theta_k$) and zero otherwise. Note that these $x$ and $y$ numbers define the dependence of $M$ on $\theta$, and are constants that do not change throughout a simulation.

This model allows one to compute simple rate matrix structure where the elements of the rate matrix are simply parameters.  An example in MacPan is the following.
```{r, eval=FALSE}
afun("Ia", "R", gamma_a)
```
This model also allows products of parameters and complements of parameters, such as this example from MacPan.
```{r, eval=FALSE}
afun("Is", "ICUs", (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * gamma_s)
```

### More General Rate Matrix Model

#### Motivation for generalization

The above warm up model is too restrictive for some rate matrix elements, with the most important example being the force of infection. Here is a definition of the force of infection that is equivalent (I think) to what MacPan uses (at least in some cases).
```{r, eval=FALSE}
afun("S", "E", sum(state[c("Ia", "Ip", "Im", "Is")] 
  * beta0 
  * c(Ca, Cp, (1 - iso_m) * Cm, (1 - iso_s) * Cs) 
  / N))
```

To accommodate such force of infection updates and others, we define a more general model that allows the following additional operations.

1. state variables can be used, in addition to parameters
2. parameters and state variables can be inverted, in addition to complements
3. products of parameters, state variables, and their inverses and complements can be added together

#### User Interface

Users can define the structure of a rate matrix with a list of expressions, each determining the parameter and state dependence of a non-zero rate matrix element. For example,
```{r, eval=FALSE}
list(
  # recovery
  list(from = "Ia", to = "R",    
       formula = ~ (gamma_a)),
  # hospitalizations
  list(from = "Is", to = "ICUs", 
       formula = ~ (1 - nonhosp_mort) * (1 - phi1) * (1 - phi2) * (gamma_s)),
  # force of infection
  list(from = "S",  to = "E",
       formula = ~ 
         (Ia) * (beta0) * (1/N) * (Ca) + 
         (Ip) * (beta0) * (1/N) * (Cp) + 
         (Im) * (beta0) * (1/N) * (Cm) * (1-iso_m) + 
         (Is) * (beta0) * (1/N) * (Cs) * (1-iso_m)),
  list('etc...')
)
```
The formulas allow the following operations:

* Any element, $x$, of either the parameter or state vector can be placed _in parentheses_ to produce a _factor_ in one of the following three forms
  * Identity: `(x)`
  * Complement: `(1-x)`
  * Inverse: `(1/x)`
* Any number of factors can be multiplied together using `*` to produce a _product_
* Any number of factors and products can be added together using `+`

#### Mathematical Model Description

We make a series of transformations from the state vector, $s$, and parameter vector to the rate matrix, $M$. Given how TMB works, we need to distinguish parameters that will be optimized, $\theta$, from those that will remain constant, $\eta$ (or those that are derived from parameters being optimized, e.g. time-varying??, still unsure how time varying machinery is working with run_sim_break or will work with run_sim_loglin). We define two intermediate vectors as well: the factor vector, $v$, and the product vector, $u$. At a high level we take the elements of the state vector and two parameter vectors into the non-zero elements of the rate matrix as follows.
$$
\{s,\eta,\theta\} \rightarrow v \rightarrow u \rightarrow M
$$

The factor vector, $v$, is a function of $s$ and $\theta$.  The dependence is simple in that each scalar element of the factor vector can be one of the following.

* [identity] an element, $x$, of either $s$ or $\theta$
* [complement] the complement of this element, $1-x$
* [inverse] the inverse of this element, $1/x$

In the future we can generalize this by adding more operations, but for now identity, complement, and inverse should get us pretty far -- although it will make age structure awkward given that such problems are more naturally handled with matrix operations like Kronecker products and sweeps.

The product vector, $u$, is a function of $v$.  The dependence is simple in that each element of the product vector is the product of one or more elements of the factor vector, $v$.

The non-zero elements of the rate matrix, $M$, can be any one of the following.

* An element of the factor vector, $v$
* An element of the product vector, $u$
* The sum of one or more elements in the product vector, $u$

Explicitly expressing the force of infection in terms of this model we have.

$$
s = [I_a, I_p, I_m, I_s]
$$

$$
\theta = [\beta_0, C_a, C_p, C_m, C_s, iso_m, iso_s, N]
$$

$$
u = [s_1, s_2, s_3, s_4, \theta_1, \theta_2, \theta_3, \theta_4, \theta_5, 1 - \theta_6, 1 - \theta_7, 1/\theta_8]
$$

$$
v = [u_1  u_5  u_6          u_{12}, 
     u_2  u_5  u_7          u_{12},
     u_3  u_5  u_{10}  u_8  u_{12},
     u_4  u_5  u_{11}  u_9  u_{12}]
$$

And the non-zero element of $M$ determining the rate of flow from S to E is the sum of the elements in the products vector, $v$. Typically this summation will be taken over a subset of the elements of the products vector, but we simplified this example to include on elements that are involved in the force of infection computation.

## Roadmap

### Avoid Copying on the R-Side

Although the overall motivation for this work is to facilitate C++/TMB refactoring, it would be good to have the R-side version as efficient as possible.

### Constants

Could be convenient to just allow users to hard code constant rate matrix entries in the rate matrix structure. This is an example from MacPan.
```{r, eval=FALSE}
afun("H", "D", 0)
```
I'm surprised this is necessary though because I have been assuming that unspecified rate matrix elements imply zero.

### Regex Matching

Not thinking about this at all, but probably should.  For example, could `pfun` return multiple rate matrix positions?  If so that would screw up the current index machinery.

### Index Permutations

Permutation of the parameter, state, and factor vectors for computational efficiency. We don't want to have to sum together products that depend on elements of the state vector that are far apart from each other in memory. This is similar to permutations of sparse matrices in the Matrix package and Eigen.

### Model Specification in Terms of Matrices and Vectors

The model above treats all parameters and state variables as scalars. But in many cases it is more natural to consider vector- and matrix-valued parameters and states. For example, the contact matrix (`pmat`) that is used by MacPan in models of age-structure.

As far as I can tell models such as age structure _could_ be defined in terms of the model above (because matrix operations are composed of products and sums of products), but it would just require large numbers of tedious entries. There are two ways around this tedium. First, we could add matrix operations to the list of allowable operations in the rate matrix update model. Second, we could create convenience model-specification utilities that would automatically expand to the notation used in the above model. I'm not sure which one I like better, but the first one could take advantage of sparse matrix optimizations from Eigen etc. On the other hand, maybe we can get similar performance with smart index permutations on the R-side?

## Unstructured Notes

When coding this up, we do not need to explicitly store all of the zeros in $x$ and $y$. Instead we just track what elements of $M$ depend on what elements of $\theta$ and whether/how the dependence involves complements of the values of $\theta$.

Before defining the interface, assume that we have a rate matrix on the R-side with named rows and columns, and a named parameter vector also on the R-side with named elements.
```{r}
theta <- McMasterPandemic:::read_params("ICU1.csv")
state = McMasterPandemic:::make_state(params=theta)
M <- McMasterPandemic:::make_ratemat(params=theta, state=state, sparse=TRUE)
print(theta)
print(M)
```

```{r}
state_names = row.names(M)
par_names = names(theta)
print(state_names)
print(par_names)
```


```{r}
pfun <- McMasterPandemic:::pfun
```


```{r}
make_beta_light <- function(state, params, full = TRUE) {
    # does not use 'full' (argument)
    # does not use 'testcats' (below)
    Icats <- c("Ia", "Ip", "Im", "Is")
    testcats <- c("_u", "_p", "_n", "_t")
    Icat_prop_vec <- with(
        as.list(params),
        c(Ca, Cp, (1 - iso_m) * Cm, (1 - iso_s) * Cs)
    )
    names(Icat_prop_vec) <- Icats
    beta_0 <- with(as.list(params), beta0 * Icat_prop_vec / N)
    beta <- setNames(numeric(length(state)), names(state))
    beta[names(beta_0)] <- beta_0
    return(beta)
}

update_ratemat_light <- function(ratemat, state, params, testwt_scale = "N") {
  # testwt_scale not needed
  ratemat[pfun("S", "E", ratemat)] <- update_foi(state, params, make_beta(state, params))
}

update_foi_light <- function(state, params, beta) {
  # params not needed
  foi <- sum(state * beta)
}

```



